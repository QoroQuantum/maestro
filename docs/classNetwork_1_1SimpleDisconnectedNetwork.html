<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Maestro: Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Maestro<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Unified interface for quantum circuit simulation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classNetwork_1_1SimpleDisconnectedNetwork.html','','classNetwork_1_1SimpleDisconnectedNetwork-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The simple network implementation.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classNetwork_1_1SimpleDisconnectedNetwork.png" usemap="#Network_3A_3ASimpleDisconnectedNetwork_3C_20Time_2C_20Controller_20_3E_map" alt=""/>
  <map id="Network_3A_3ASimpleDisconnectedNetwork_3C_20Time_2C_20Controller_20_3E_map" name="Network_3A_3ASimpleDisconnectedNetwork_3C_20Time_2C_20Controller_20_3E_map">
<area href="classNetwork_1_1INetwork.html" alt="Network::INetwork&lt; Types::time_type &gt;" shape="rect" coords="0,56,366,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ada086141239589722e9b4753ed4ed73d" id="r_ada086141239589722e9b4753ed4ed73d"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#ada086141239589722e9b4753ed4ed73d">BaseClass</a> = <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt;Time&gt;</td></tr>
<tr class="memdesc:ada086141239589722e9b4753ed4ed73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class type.  <br /></td></tr>
<tr class="memitem:a1537dfd62f404ccfbfd5cebf9e87b5ae" id="r_a1537dfd62f404ccfbfd5cebf9e87b5ae"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#a1537dfd62f404ccfbfd5cebf9e87b5ae">ExecuteResults</a></td></tr>
<tr class="memdesc:a1537dfd62f404ccfbfd5cebf9e87b5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The execute results type.  <br /></td></tr>
<tr class="inherit_header pub_types_classNetwork_1_1INetwork"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classNetwork_1_1INetwork')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Types inherited from <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork&lt; Types::time_type &gt;</a></td></tr>
<tr class="memitem:aa7e4e730dac51e0ae031528ecdfe7378 inherit pub_types_classNetwork_1_1INetwork" id="r_aa7e4e730dac51e0ae031528ecdfe7378"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#aa7e4e730dac51e0ae031528ecdfe7378">ExecuteResults</a></td></tr>
<tr class="memitem:a553107e4963cba9290e0fefed22912e3 inherit pub_types_classNetwork_1_1INetwork" id="r_a553107e4963cba9290e0fefed22912e3"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a553107e4963cba9290e0fefed22912e3">SimulatorPair</a></td></tr>
<tr class="memitem:aa948773ddeeadbf03487095c5ac1da11 inherit pub_types_classNetwork_1_1INetwork" id="r_aa948773ddeeadbf03487095c5ac1da11"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#aa948773ddeeadbf03487095c5ac1da11">SimulatorsSet</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af23afa210e1774159a5517151a6ed410" id="r_af23afa210e1774159a5517151a6ed410"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#af23afa210e1774159a5517151a6ed410">SimpleDisconnectedNetwork</a> (const std::vector&lt; <a class="el" href="namespaceTypes.html#afda27b666a29ff2e858b10ee1a7e4b73">Types::qubit_t</a> &gt; &amp;qubits={}, const std::vector&lt; size_t &gt; &amp;cbits={})</td></tr>
<tr class="memdesc:af23afa210e1774159a5517151a6ed410"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor.  <br /></td></tr>
<tr class="memitem:af1d1a2dfa2db52516640d7324487d55d" id="r_af1d1a2dfa2db52516640d7324487d55d"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#af1d1a2dfa2db52516640d7324487d55d">CreateNetwork</a> (const std::vector&lt; <a class="el" href="namespaceTypes.html#afda27b666a29ff2e858b10ee1a7e4b73">Types::qubit_t</a> &gt; &amp;qubits, const std::vector&lt; size_t &gt; &amp;cbits)</td></tr>
<tr class="memdesc:af1d1a2dfa2db52516640d7324487d55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the network hosts and controller.  <br /></td></tr>
<tr class="memitem:a76c5d531223dad99ee8c48f4695e0107" id="r_a76c5d531223dad99ee8c48f4695e0107"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a76c5d531223dad99ee8c48f4695e0107">Execute</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit) override</td></tr>
<tr class="memdesc:a76c5d531223dad99ee8c48f4695e0107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the network.  <br /></td></tr>
<tr class="memitem:a10a2aa943a0bd764a2edc61972ccf5e2" id="r_a10a2aa943a0bd764a2edc61972ccf5e2"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a10a2aa943a0bd764a2edc61972ccf5e2">ExecuteOnHost</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit, size_t hostId) override</td></tr>
<tr class="memdesc:a10a2aa943a0bd764a2edc61972ccf5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the specified host.  <br /></td></tr>
<tr class="memitem:a02f42154e8fba4d72caa9b37b35a0a41" id="r_a02f42154e8fba4d72caa9b37b35a0a41"><td class="memItemLeft">std::vector&lt; double &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a02f42154e8fba4d72caa9b37b35a0a41">ExecuteExpectations</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit, const std::vector&lt; std::string &gt; &amp;paulis) override</td></tr>
<tr class="memdesc:a02f42154e8fba4d72caa9b37b35a0a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the network and return the expectation values for the specified Pauli strings.  <br /></td></tr>
<tr class="memitem:a94d87f73b94d27595cde311c846d1e21" id="r_a94d87f73b94d27595cde311c846d1e21"><td class="memItemLeft">std::vector&lt; double &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a94d87f73b94d27595cde311c846d1e21">ExecuteOnHostExpectations</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit, size_t hostId, const std::vector&lt; std::string &gt; &amp;paulis)</td></tr>
<tr class="memdesc:a94d87f73b94d27595cde311c846d1e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the specified host and return the expectation values for the specified Pauli strings.  <br /></td></tr>
<tr class="memitem:a2d5710c5da315173effc677c3ddaa113" id="r_a2d5710c5da315173effc677c3ddaa113"><td class="memItemLeft"><a class="el" href="#a1537dfd62f404ccfbfd5cebf9e87b5ae">ExecuteResults</a>&#160;</td><td class="memItemRight"><a class="el" href="#a2d5710c5da315173effc677c3ddaa113">RepeatedExecute</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit, size_t shots=1000) override</td></tr>
<tr class="memdesc:a2d5710c5da315173effc677c3ddaa113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the network, repeatedly.  <br /></td></tr>
<tr class="memitem:a28c0df1f01d0e55828a1bfb65277589c" id="r_a28c0df1f01d0e55828a1bfb65277589c"><td class="memItemLeft"><a class="el" href="#a1537dfd62f404ccfbfd5cebf9e87b5ae">ExecuteResults</a>&#160;</td><td class="memItemRight"><a class="el" href="#a28c0df1f01d0e55828a1bfb65277589c">RepeatedExecuteOnHost</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit, size_t hostId, size_t shots=1000) override</td></tr>
<tr class="memdesc:a28c0df1f01d0e55828a1bfb65277589c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the specified host, repeatedly.  <br /></td></tr>
<tr class="memitem:a339d55ef40533b3cbcf377629e83f160" id="r_a339d55ef40533b3cbcf377629e83f160"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#a339d55ef40533b3cbcf377629e83f160">GetNumberOfGatesDistributedOrCut</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit) const override</td></tr>
<tr class="memdesc:a339d55ef40533b3cbcf377629e83f160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of gates that span more than one host.  <br /></td></tr>
<tr class="memitem:a837a373546b78cc3f1a2da25204f9081" id="r_a837a373546b78cc3f1a2da25204f9081"><td class="memItemLeft">std::vector&lt; <a class="el" href="#a1537dfd62f404ccfbfd5cebf9e87b5ae">ExecuteResults</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a837a373546b78cc3f1a2da25204f9081">ExecuteScheduled</a> (const std::vector&lt; <a class="el" href="structSchedulers_1_1ExecuteCircuit.html">Schedulers::ExecuteCircuit</a>&lt; Time &gt; &gt; &amp;circuits) override</td></tr>
<tr class="memdesc:a837a373546b78cc3f1a2da25204f9081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule and execute circuits on the network.  <br /></td></tr>
<tr class="memitem:a3eee70024a100f2d13da135e4fc94214" id="r_a3eee70024a100f2d13da135e4fc94214"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a3eee70024a100f2d13da135e4fc94214">CreateSimulator</a> (<a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a> simType=<a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aaa20dd7a84a53e5ace6f43951e3f0b0337">Simulators::SimulatorType::kQCSim</a>, <a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a> simExecType=<a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789a62f6eb80f4ebe16a28e8405dffac7fea">Simulators::SimulationType::kMatrixProductState</a>, size_t nrQubits=0) override</td></tr>
<tr class="memdesc:a3eee70024a100f2d13da135e4fc94214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the simulator for the network.  <br /></td></tr>
<tr class="memitem:a3beaae2be8da41f5362532960cf984aa" id="r_a3beaae2be8da41f5362532960cf984aa"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a3beaae2be8da41f5362532960cf984aa">Configure</a> (const char *key, const char *value) override</td></tr>
<tr class="memdesc:a3beaae2be8da41f5362532960cf984aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the network.  <br /></td></tr>
<tr class="memitem:abdba56e38cd3e43847e664791510d980" id="r_abdba56e38cd3e43847e664791510d980"><td class="memItemLeft">std::shared_ptr&lt; <a class="el" href="classSimulators_1_1ISimulator.html">Simulators::ISimulator</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#abdba56e38cd3e43847e664791510d980">GetSimulator</a> () const override</td></tr>
<tr class="memdesc:abdba56e38cd3e43847e664791510d980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the simulator for the network.  <br /></td></tr>
<tr class="memitem:a231f579e098ac6597b4c92963ec15f21" id="r_a231f579e098ac6597b4c92963ec15f21"><td class="memItemLeft"><a class="el" href="classCircuits_1_1OperationState.html">Circuits::OperationState</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a231f579e098ac6597b4c92963ec15f21">GetState</a> () override</td></tr>
<tr class="memdesc:a231f579e098ac6597b4c92963ec15f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the classical state of the network.  <br /></td></tr>
<tr class="memitem:ac5c495840beeaa043b4b7ec85cd18bb7" id="r_ac5c495840beeaa043b4b7ec85cd18bb7"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#ac5c495840beeaa043b4b7ec85cd18bb7">CreateScheduler</a> (<a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1">SchedulerType</a> schType=<a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1ab90c9b48118b61527e8d21a4bb699c4b">SchedulerType::kNoEntanglementQubitsParallel</a>) override</td></tr>
<tr class="memdesc:ac5c495840beeaa043b4b7ec85cd18bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the scheduler for the network.  <br /></td></tr>
<tr class="memitem:a9d2c5711de54c064387946b8381ce250" id="r_a9d2c5711de54c064387946b8381ce250"><td class="memItemLeft">std::shared_ptr&lt; <a class="el" href="classSchedulers_1_1IScheduler.html">Schedulers::IScheduler</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a9d2c5711de54c064387946b8381ce250">GetScheduler</a> () const override</td></tr>
<tr class="memdesc:a9d2c5711de54c064387946b8381ce250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scheduler for the network.  <br /></td></tr>
<tr class="memitem:a4190672a3cbcc56a3daacd93555007a8" id="r_a4190672a3cbcc56a3daacd93555007a8"><td class="memItemLeft">const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1IHost.html">IHost</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a4190672a3cbcc56a3daacd93555007a8">GetHost</a> (size_t hostId) const override</td></tr>
<tr class="memdesc:a4190672a3cbcc56a3daacd93555007a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the host with the specified id.  <br /></td></tr>
<tr class="memitem:aaaef4e5472e4dd6cc177c5a26a408622" id="r_aaaef4e5472e4dd6cc177c5a26a408622"><td class="memItemLeft">const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1IController.html">IController</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#aaaef4e5472e4dd6cc177c5a26a408622">GetController</a> () const override</td></tr>
<tr class="memdesc:aaaef4e5472e4dd6cc177c5a26a408622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the controller for the network.  <br /></td></tr>
<tr class="memitem:a46f9387675110a28a81c10794f3f1c45" id="r_a46f9387675110a28a81c10794f3f1c45"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#a46f9387675110a28a81c10794f3f1c45">GetNumHosts</a> () const override</td></tr>
<tr class="memdesc:a46f9387675110a28a81c10794f3f1c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of hosts in the network.  <br /></td></tr>
<tr class="memitem:a31c2704fa3dc82eaf63005774231deca" id="r_a31c2704fa3dc82eaf63005774231deca"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#a31c2704fa3dc82eaf63005774231deca">GetNumQubits</a> () const override</td></tr>
<tr class="memdesc:a31c2704fa3dc82eaf63005774231deca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of qubits in the network.  <br /></td></tr>
<tr class="memitem:a22737771248b0de2aaa230360db6cdf0" id="r_a22737771248b0de2aaa230360db6cdf0"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#a22737771248b0de2aaa230360db6cdf0">GetNumQubitsForHost</a> (size_t hostId) const override</td></tr>
<tr class="memdesc:a22737771248b0de2aaa230360db6cdf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of qubits in the network for the specified host.  <br /></td></tr>
<tr class="memitem:a1b978a5df60184fcf694e53d495b738d" id="r_a1b978a5df60184fcf694e53d495b738d"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#a1b978a5df60184fcf694e53d495b738d">GetNumNetworkEntangledQubits</a> () const override</td></tr>
<tr class="memdesc:a1b978a5df60184fcf694e53d495b738d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of qubits used for entanglement between hosts.  <br /></td></tr>
<tr class="memitem:a8dc46b6119038c7ee8b62c6db36ffb56" id="r_a8dc46b6119038c7ee8b62c6db36ffb56"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#a8dc46b6119038c7ee8b62c6db36ffb56">GetNumNetworkEntangledQubitsForHost</a> (size_t hostId) const override</td></tr>
<tr class="memdesc:a8dc46b6119038c7ee8b62c6db36ffb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of qubits used for entanglement between hosts for the specified host.  <br /></td></tr>
<tr class="memitem:a9dd489fb138feee985beb73a87f4059a" id="r_a9dd489fb138feee985beb73a87f4059a"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#a9dd489fb138feee985beb73a87f4059a">GetNumClassicalBits</a> () const override</td></tr>
<tr class="memdesc:a9dd489fb138feee985beb73a87f4059a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of classical bits in the network.  <br /></td></tr>
<tr class="memitem:a702fc9d436751911472e0cbde2eec518" id="r_a702fc9d436751911472e0cbde2eec518"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#a702fc9d436751911472e0cbde2eec518">GetNumClassicalBitsForHost</a> (size_t hostId) const override</td></tr>
<tr class="memdesc:a702fc9d436751911472e0cbde2eec518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of classical bits in the network for the specified host.  <br /></td></tr>
<tr class="memitem:aafc29ca8168432221397e765410e2836" id="r_aafc29ca8168432221397e765410e2836"><td class="memItemLeft">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classNetwork_1_1IHost.html">IHost</a>&lt; Time &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight"><a class="el" href="#aafc29ca8168432221397e765410e2836">GetHosts</a> ()</td></tr>
<tr class="memdesc:aafc29ca8168432221397e765410e2836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hosts in the network.  <br /></td></tr>
<tr class="memitem:a026f0fe48a279022b64bd962c6bef0ea" id="r_a026f0fe48a279022b64bd962c6bef0ea"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a026f0fe48a279022b64bd962c6bef0ea">SetController</a> (const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1IController.html">IController</a>&lt; Time &gt; &gt; &amp;cntrl)</td></tr>
<tr class="memdesc:a026f0fe48a279022b64bd962c6bef0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the network controller host.  <br /></td></tr>
<tr class="memitem:ab79d8495b514562b0358ce37d63ceb2b" id="r_ab79d8495b514562b0358ce37d63ceb2b"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#ab79d8495b514562b0358ce37d63ceb2b">SendPacket</a> (size_t fromHostId, size_t toHostId, const std::vector&lt; uint8_t &gt; &amp;packet) override</td></tr>
<tr class="memdesc:ab79d8495b514562b0358ce37d63ceb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a packet between two hosts.  <br /></td></tr>
<tr class="memitem:af5f9354c22833d18b224930617ee8fe9" id="r_af5f9354c22833d18b224930617ee8fe9"><td class="memItemLeft"><a class="el" href="namespaceNetwork.html#a33e9851296c0fe8a699eab9c27ec656e">NetworkType</a>&#160;</td><td class="memItemRight"><a class="el" href="#af5f9354c22833d18b224930617ee8fe9">GetType</a> () const override</td></tr>
<tr class="memdesc:af5f9354c22833d18b224930617ee8fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the network.  <br /></td></tr>
<tr class="memitem:a374adb2fb01093a5b558011c229688dc" id="r_a374adb2fb01093a5b558011c229688dc"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a374adb2fb01093a5b558011c229688dc">IsLocalOperation</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;op) const override</td></tr>
<tr class="memdesc:a374adb2fb01093a5b558011c229688dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the circuit operation is local.  <br /></td></tr>
<tr class="memitem:aaf5164566e8f69bce7742c24b0432add" id="r_aaf5164566e8f69bce7742c24b0432add"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#aaf5164566e8f69bce7742c24b0432add">IsDistributedOperation</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;op) const override</td></tr>
<tr class="memdesc:aaf5164566e8f69bce7742c24b0432add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the circuit operation is distributed.  <br /></td></tr>
<tr class="memitem:abe1ecd77255433123c9a47e3e2a67691" id="r_abe1ecd77255433123c9a47e3e2a67691"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#abe1ecd77255433123c9a47e3e2a67691">OperatesWithNetworkEntangledQubit</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;op) const override</td></tr>
<tr class="memdesc:abe1ecd77255433123c9a47e3e2a67691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the circuit operation operates on the entanglement qubits between hosts.  <br /></td></tr>
<tr class="memitem:a7698358b31b3e41bc18eff58979b662e" id="r_a7698358b31b3e41bc18eff58979b662e"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a7698358b31b3e41bc18eff58979b662e">IsEntanglingGate</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;op) const override</td></tr>
<tr class="memdesc:a7698358b31b3e41bc18eff58979b662e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a gate is an entangling gate.  <br /></td></tr>
<tr class="memitem:a0c8dfc900846394f7676ac3a5bb59193" id="r_a0c8dfc900846394f7676ac3a5bb59193"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a0c8dfc900846394f7676ac3a5bb59193">ExpectsClassicalBitFromOtherHost</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;op) const override</td></tr>
<tr class="memdesc:a0c8dfc900846394f7676ac3a5bb59193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a gate expects a classical bit from another host.  <br /></td></tr>
<tr class="memitem:a1219ee350c2b7b06f1fa40b6c054211a" id="r_a1219ee350c2b7b06f1fa40b6c054211a"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#a1219ee350c2b7b06f1fa40b6c054211a">GetHostIdForClassicalControl</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;op) const override</td></tr>
<tr class="memdesc:a1219ee350c2b7b06f1fa40b6c054211a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the host id where the classical control bit resides for a conditioned gate.  <br /></td></tr>
<tr class="memitem:a8097c7e6113ae3df223b56791f69db20" id="r_a8097c7e6113ae3df223b56791f69db20"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a8097c7e6113ae3df223b56791f69db20">AreQubitsOnSameHost</a> (size_t qubitId1, size_t qubitId2) const override</td></tr>
<tr class="memdesc:a8097c7e6113ae3df223b56791f69db20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified qubits are on the same host.  <br /></td></tr>
<tr class="memitem:afd15438f447aea77b9fb2a548fc822a8" id="r_afd15438f447aea77b9fb2a548fc822a8"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#afd15438f447aea77b9fb2a548fc822a8">AreClassicalBitsOnSameHost</a> (size_t bitId1, size_t bitId2) const override</td></tr>
<tr class="memdesc:afd15438f447aea77b9fb2a548fc822a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified classical bits are on the same host.  <br /></td></tr>
<tr class="memitem:a6bfc7fbb149632fdf31a0233461e2293" id="r_a6bfc7fbb149632fdf31a0233461e2293"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a6bfc7fbb149632fdf31a0233461e2293">AreQubitAndClassicalBitOnSameHost</a> (size_t qubitId, size_t bitId) const override</td></tr>
<tr class="memdesc:a6bfc7fbb149632fdf31a0233461e2293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified qubit and classical bit are on the same host.  <br /></td></tr>
<tr class="memitem:a4e1c0079ea5ccd1aba336ac04514f2b8" id="r_a4e1c0079ea5ccd1aba336ac04514f2b8"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#a4e1c0079ea5ccd1aba336ac04514f2b8">GetHostIdForQubit</a> (size_t qubitId) const override</td></tr>
<tr class="memdesc:a4e1c0079ea5ccd1aba336ac04514f2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the host id for the specified qubit.  <br /></td></tr>
<tr class="memitem:a04384bbfdd7970e4e4834efa873a6d4f" id="r_a04384bbfdd7970e4e4834efa873a6d4f"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#a04384bbfdd7970e4e4834efa873a6d4f">GetHostIdForEntangledQubit</a> (size_t qubitId) const override</td></tr>
<tr class="memdesc:a04384bbfdd7970e4e4834efa873a6d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the host id for the specified qubit used for entanglement between hosts.  <br /></td></tr>
<tr class="memitem:a87b8db81eb036b773c0adf1875634540" id="r_a87b8db81eb036b773c0adf1875634540"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#a87b8db81eb036b773c0adf1875634540">GetHostIdForAnyQubit</a> (size_t qubitId) const override</td></tr>
<tr class="memdesc:a87b8db81eb036b773c0adf1875634540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the host id for the specified qubit.  <br /></td></tr>
<tr class="memitem:a36976d5eac2433ba03bf309280d75ce5" id="r_a36976d5eac2433ba03bf309280d75ce5"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#a36976d5eac2433ba03bf309280d75ce5">GetHostIdForClassicalBit</a> (size_t classicalBitId) const override</td></tr>
<tr class="memdesc:a36976d5eac2433ba03bf309280d75ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the host id for the specified classical bit.  <br /></td></tr>
<tr class="memitem:a2fe97c1659f672739a53021d4a9ec7a8" id="r_a2fe97c1659f672739a53021d4a9ec7a8"><td class="memItemLeft">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a2fe97c1659f672739a53021d4a9ec7a8">GetQubitsIds</a> (size_t hostId) const override</td></tr>
<tr class="memdesc:a2fe97c1659f672739a53021d4a9ec7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the qubit ids for the specified host.  <br /></td></tr>
<tr class="memitem:af346a968922fed1b2607879c69616499" id="r_af346a968922fed1b2607879c69616499"><td class="memItemLeft">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight"><a class="el" href="#af346a968922fed1b2607879c69616499">GetNetworkEntangledQubitsIds</a> (size_t hostId) const override</td></tr>
<tr class="memdesc:af346a968922fed1b2607879c69616499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the qubit ids used for entanglement between hosts for the specified host.  <br /></td></tr>
<tr class="memitem:ac7f34eee1300e60156c75471bd7cdcda" id="r_ac7f34eee1300e60156c75471bd7cdcda"><td class="memItemLeft">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight"><a class="el" href="#ac7f34eee1300e60156c75471bd7cdcda">GetClassicalBitsIds</a> (size_t hostId) const override</td></tr>
<tr class="memdesc:ac7f34eee1300e60156c75471bd7cdcda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the classical bit ids for the specified host.  <br /></td></tr>
<tr class="memitem:ac8499d79e66d8bc04d140d28f7e415d2" id="r_ac8499d79e66d8bc04d140d28f7e415d2"><td class="memItemLeft">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight"><a class="el" href="#ac8499d79e66d8bc04d140d28f7e415d2">GetEntangledQubitMeasurementBitIds</a> (size_t hostId) const override</td></tr>
<tr class="memdesc:ac8499d79e66d8bc04d140d28f7e415d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the classical bit ids used for measurement of entanglement qubits between the hosts for the specified host.  <br /></td></tr>
<tr class="memitem:a514869063d4a922289c553126ecd9513" id="r_a514869063d4a922289c553126ecd9513"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a514869063d4a922289c553126ecd9513">IsNetworkEntangledQubit</a> (size_t qubitId) const override</td></tr>
<tr class="memdesc:a514869063d4a922289c553126ecd9513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified qubit id is for a qubit used for entanglement between hosts.  <br /></td></tr>
<tr class="memitem:ae929327ee3fe961a4838a6df9bc904bd" id="r_ae929327ee3fe961a4838a6df9bc904bd"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#ae929327ee3fe961a4838a6df9bc904bd">IsEntanglementQubitBusy</a> (size_t qubitId) const override</td></tr>
<tr class="memdesc:ae929327ee3fe961a4838a6df9bc904bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified qubit used for entanglement between hosts is busy.  <br /></td></tr>
<tr class="memitem:ad78a8a5a095c7a67c151b91817baffd0" id="r_ad78a8a5a095c7a67c151b91817baffd0"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#ad78a8a5a095c7a67c151b91817baffd0">AreEntanglementQubitsBusy</a> (size_t qubitId1, size_t qubitId2) const override</td></tr>
<tr class="memdesc:ad78a8a5a095c7a67c151b91817baffd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any of the two specified qubits used for entanglement between hosts are busy.  <br /></td></tr>
<tr class="memitem:ac4476e8cad5690ab82646d426dabbb02" id="r_ac4476e8cad5690ab82646d426dabbb02"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#ac4476e8cad5690ab82646d426dabbb02">MarkEntangledQubitsBusy</a> (size_t qubitId1, size_t qubitId2) override</td></tr>
<tr class="memdesc:ac4476e8cad5690ab82646d426dabbb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the pair of the specified qubits used for entanglement between hosts as busy.  <br /></td></tr>
<tr class="memitem:a15e13bf36e6bc35af21916c6c6b5304a" id="r_a15e13bf36e6bc35af21916c6c6b5304a"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a15e13bf36e6bc35af21916c6c6b5304a">MarkEntangledQubitFree</a> (size_t qubitId) override</td></tr>
<tr class="memdesc:a15e13bf36e6bc35af21916c6c6b5304a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the specified qubit used for entanglement between hosts as free.  <br /></td></tr>
<tr class="memitem:adc457460c0cd933d072808da878b271e" id="r_adc457460c0cd933d072808da878b271e"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#adc457460c0cd933d072808da878b271e">ClearEntanglements</a> () override</td></tr>
<tr class="memdesc:adc457460c0cd933d072808da878b271e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all entanglements between hosts in the network.  <br /></td></tr>
<tr class="memitem:a3128d73e5b2c2a35571b7413a83bd48f" id="r_a3128d73e5b2c2a35571b7413a83bd48f"><td class="memItemLeft">std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a3128d73e5b2c2a35571b7413a83bd48f">GetDistributedCircuit</a> () const override</td></tr>
<tr class="memdesc:a3128d73e5b2c2a35571b7413a83bd48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distributed circuit.  <br /></td></tr>
<tr class="memitem:a02697dcb575dadb6060ca5d60ccdeffd" id="r_a02697dcb575dadb6060ca5d60ccdeffd"><td class="memItemLeft"><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a>&#160;</td><td class="memItemRight"><a class="el" href="#a02697dcb575dadb6060ca5d60ccdeffd">GetLastSimulatorType</a> () const override</td></tr>
<tr class="memdesc:a02697dcb575dadb6060ca5d60ccdeffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last used simulator type.  <br /></td></tr>
<tr class="memitem:a6492ca625156136c2e438083093b2ef7" id="r_a6492ca625156136c2e438083093b2ef7"><td class="memItemLeft"><a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a>&#160;</td><td class="memItemRight"><a class="el" href="#a6492ca625156136c2e438083093b2ef7">GetLastSimulationType</a> () const override</td></tr>
<tr class="memdesc:a6492ca625156136c2e438083093b2ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last used simulation type.  <br /></td></tr>
<tr class="memitem:ac384bc3121527e1334aa886ebb21fb87" id="r_ac384bc3121527e1334aa886ebb21fb87"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#ac384bc3121527e1334aa886ebb21fb87">GetMaxSimulators</a> () const override</td></tr>
<tr class="memdesc:ac384bc3121527e1334aa886ebb21fb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of simulators that can be used in the network.  <br /></td></tr>
<tr class="memitem:a666367ed32af514cc8a653bc06bc293a" id="r_a666367ed32af514cc8a653bc06bc293a"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a666367ed32af514cc8a653bc06bc293a">SetMaxSimulators</a> (size_t val) override</td></tr>
<tr class="memdesc:a666367ed32af514cc8a653bc06bc293a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of simulators that can be used in the network.  <br /></td></tr>
<tr class="memitem:a6f51d41faf736e0e8cb9ebe236ff6b88" id="r_a6f51d41faf736e0e8cb9ebe236ff6b88"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a6f51d41faf736e0e8cb9ebe236ff6b88">SetOptimizeSimulator</a> (bool optimize=true) override</td></tr>
<tr class="memdesc:a6f51d41faf736e0e8cb9ebe236ff6b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows using an optimized simulator.  <br /></td></tr>
<tr class="memitem:a329778029550a5ead52e77e1966ecb40" id="r_a329778029550a5ead52e77e1966ecb40"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a329778029550a5ead52e77e1966ecb40">GetOptimizeSimulator</a> () const override</td></tr>
<tr class="memdesc:a329778029550a5ead52e77e1966ecb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 'optimize' flag.  <br /></td></tr>
<tr class="memitem:ab8a12099dd76cd1c7c63b960405d95a3" id="r_ab8a12099dd76cd1c7c63b960405d95a3"><td class="memItemLeft">const <a class="el" href="classNetwork_1_1INetwork.html#aa948773ddeeadbf03487095c5ac1da11">BaseClass::SimulatorsSet</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#ab8a12099dd76cd1c7c63b960405d95a3">GetSimulatorsSet</a> () const override</td></tr>
<tr class="memdesc:ab8a12099dd76cd1c7c63b960405d95a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the optimizations simulators set.  <br /></td></tr>
<tr class="memitem:a2424468039a56fa0b6d96604db08f828" id="r_a2424468039a56fa0b6d96604db08f828"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a2424468039a56fa0b6d96604db08f828">AddOptimizationSimulator</a> (<a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a> type, <a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a> kind) override</td></tr>
<tr class="memdesc:a2424468039a56fa0b6d96604db08f828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a simulator to the simulators optimization set.  <br /></td></tr>
<tr class="memitem:a5823dfcf86f0df4872a16d7b9eb89d65" id="r_a5823dfcf86f0df4872a16d7b9eb89d65"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a5823dfcf86f0df4872a16d7b9eb89d65">RemoveOptimizationSimulator</a> (<a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a> type, <a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a> kind) override</td></tr>
<tr class="memdesc:a5823dfcf86f0df4872a16d7b9eb89d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a simulator from the simulators optimization set.  <br /></td></tr>
<tr class="memitem:aed8f20ae183d2357bdfda05ec88d2450" id="r_aed8f20ae183d2357bdfda05ec88d2450"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#aed8f20ae183d2357bdfda05ec88d2450">RemoveAllOptimizationSimulatorsAndAdd</a> (<a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a> type, <a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a> kind) override</td></tr>
<tr class="memdesc:aed8f20ae183d2357bdfda05ec88d2450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all simulators from the simulators optimization set and adds the one specified.  <br /></td></tr>
<tr class="memitem:a1943e1e449c97dccd8af0d8791071399" id="r_a1943e1e449c97dccd8af0d8791071399"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a1943e1e449c97dccd8af0d8791071399">OptimizationSimulatorExists</a> (<a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a> type, <a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a> kind) const override</td></tr>
<tr class="memdesc:a1943e1e449c97dccd8af0d8791071399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a simulator exists in the optimization set.  <br /></td></tr>
<tr class="memitem:a5b1a1277feaaad66db284db1f7fe1569" id="r_a5b1a1277feaaad66db284db1f7fe1569"><td class="memItemLeft">std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a5b1a1277feaaad66db284db1f7fe1569">Clone</a> () const override</td></tr>
<tr class="memdesc:a5b1a1277feaaad66db284db1f7fe1569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the network.  <br /></td></tr>
<tr class="memitem:a95bce95dcc734c6c03a9bc8eebcaa279" id="r_a95bce95dcc734c6c03a9bc8eebcaa279"><td class="memItemLeft">std::shared_ptr&lt; <a class="el" href="classSimulators_1_1ISimulator.html">Simulators::ISimulator</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a95bce95dcc734c6c03a9bc8eebcaa279">ChooseBestSimulator</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;dcirc, size_t &amp;counts, size_t nrQubits, size_t nrCbits, size_t nrResultCbits, <a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a> &amp;simType, <a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a> &amp;method, std::vector&lt; bool &gt; &amp;executed, bool multithreading=false, bool dontRunCircuitStart=false) const override</td></tr>
<tr class="inherit_header pub_methods_classNetwork_1_1INetwork"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classNetwork_1_1INetwork')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork&lt; Types::time_type &gt;</a></td></tr>
<tr class="memitem:a5ab3268ca8816f31d22c65a7bcdba609 inherit pub_methods_classNetwork_1_1INetwork" id="r_a5ab3268ca8816f31d22c65a7bcdba609"><td class="memItemLeft">virtual&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a5ab3268ca8816f31d22c65a7bcdba609">~INetwork</a> ()=default</td></tr>
<tr class="memdesc:a5ab3268ca8816f31d22c65a7bcdba609 inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="classNetwork_1_1INetwork.html" title="The network interface.">INetwork</a> object.  <br /></td></tr>
<tr class="memitem:a4a09ddecdeb48ce7e5ef09a67ab813d8 inherit pub_methods_classNetwork_1_1INetwork" id="r_a4a09ddecdeb48ce7e5ef09a67ab813d8"><td class="memItemLeft">virtual size_t&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a4a09ddecdeb48ce7e5ef09a67ab813d8">GetNumberOfGatesDistributedOrCut</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;circuit) const=0</td></tr>
<tr class="memdesc:a4a09ddecdeb48ce7e5ef09a67ab813d8 inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of gates that span more than one host.  <br /></td></tr>
<tr class="memitem:a08b1adb6d8cb973553490cdba72ee264 inherit pub_methods_classNetwork_1_1INetwork" id="r_a08b1adb6d8cb973553490cdba72ee264"><td class="memItemLeft">virtual void&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a08b1adb6d8cb973553490cdba72ee264">Execute</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;circuit)=0</td></tr>
<tr class="memdesc:a08b1adb6d8cb973553490cdba72ee264 inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the network.  <br /></td></tr>
<tr class="memitem:ac7b5e621b3f084e00a681c914176bc56 inherit pub_methods_classNetwork_1_1INetwork" id="r_ac7b5e621b3f084e00a681c914176bc56"><td class="memItemLeft">virtual void&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#ac7b5e621b3f084e00a681c914176bc56">ExecuteOnHost</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;circuit, size_t hostId)=0</td></tr>
<tr class="memdesc:ac7b5e621b3f084e00a681c914176bc56 inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the specified host.  <br /></td></tr>
<tr class="memitem:a373c422b6f4a2895bfe95daba2744c35 inherit pub_methods_classNetwork_1_1INetwork" id="r_a373c422b6f4a2895bfe95daba2744c35"><td class="memItemLeft">virtual std::vector&lt; double &gt;&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a373c422b6f4a2895bfe95daba2744c35">ExecuteExpectations</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;circuit, const std::vector&lt; std::string &gt; &amp;paulis)=0</td></tr>
<tr class="memdesc:a373c422b6f4a2895bfe95daba2744c35 inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the network and return the expectation values for the specified Pauli strings.  <br /></td></tr>
<tr class="memitem:a66764ee7024642ef150d7765abf084a2 inherit pub_methods_classNetwork_1_1INetwork" id="r_a66764ee7024642ef150d7765abf084a2"><td class="memItemLeft">virtual std::vector&lt; double &gt;&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a66764ee7024642ef150d7765abf084a2">ExecuteOnHostExpectations</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;circuit, size_t hostId, const std::vector&lt; std::string &gt; &amp;paulis)=0</td></tr>
<tr class="memdesc:a66764ee7024642ef150d7765abf084a2 inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the specified host and return the expectation values for the specified Pauli strings.  <br /></td></tr>
<tr class="memitem:a19cbf8ca93efdc7d9e2c1bae521e5065 inherit pub_methods_classNetwork_1_1INetwork" id="r_a19cbf8ca93efdc7d9e2c1bae521e5065"><td class="memItemLeft">virtual <a class="el" href="classNetwork_1_1INetwork.html#aa7e4e730dac51e0ae031528ecdfe7378">ExecuteResults</a>&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a19cbf8ca93efdc7d9e2c1bae521e5065">RepeatedExecute</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;circuit, size_t shots=1000)=0</td></tr>
<tr class="memdesc:a19cbf8ca93efdc7d9e2c1bae521e5065 inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the network, repeatedly.  <br /></td></tr>
<tr class="memitem:a494d28f1e405949d50dbfda9feee3950 inherit pub_methods_classNetwork_1_1INetwork" id="r_a494d28f1e405949d50dbfda9feee3950"><td class="memItemLeft"><a class="el" href="classNetwork_1_1INetwork.html#aa7e4e730dac51e0ae031528ecdfe7378">ExecuteResults</a>&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a494d28f1e405949d50dbfda9feee3950">RepeatedExecuteCircuit</a> (const <a class="el" href="structSchedulers_1_1ExecuteCircuit.html">Schedulers::ExecuteCircuit</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &amp;executeCircuit)</td></tr>
<tr class="memdesc:a494d28f1e405949d50dbfda9feee3950 inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the network, repeatedly.  <br /></td></tr>
<tr class="memitem:a4c390106c9a7fbd4860052fc38b96665 inherit pub_methods_classNetwork_1_1INetwork" id="r_a4c390106c9a7fbd4860052fc38b96665"><td class="memItemLeft">virtual <a class="el" href="classNetwork_1_1INetwork.html#aa7e4e730dac51e0ae031528ecdfe7378">ExecuteResults</a>&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a4c390106c9a7fbd4860052fc38b96665">RepeatedExecuteOnHost</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;circuit, size_t hostId, size_t shots=1000)=0</td></tr>
<tr class="memdesc:a4c390106c9a7fbd4860052fc38b96665 inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the specified host, repeatedly.  <br /></td></tr>
<tr class="memitem:a2642458270fe90107586695b550fac51 inherit pub_methods_classNetwork_1_1INetwork" id="r_a2642458270fe90107586695b550fac51"><td class="memItemLeft"><a class="el" href="classNetwork_1_1INetwork.html#aa7e4e730dac51e0ae031528ecdfe7378">ExecuteResults</a>&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a2642458270fe90107586695b550fac51">RepeatedExecuteCircuitOnHost</a> (const <a class="el" href="structSchedulers_1_1ExecuteCircuit.html">Schedulers::ExecuteCircuit</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &amp;executeCircuit, size_t hostId)</td></tr>
<tr class="memdesc:a2642458270fe90107586695b550fac51 inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the specified host, repeatedly.  <br /></td></tr>
<tr class="memitem:a5e8996656e5c376f82c9b5371931341c inherit pub_methods_classNetwork_1_1INetwork" id="r_a5e8996656e5c376f82c9b5371931341c"><td class="memItemLeft">virtual std::vector&lt; <a class="el" href="classNetwork_1_1INetwork.html#aa7e4e730dac51e0ae031528ecdfe7378">ExecuteResults</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a5e8996656e5c376f82c9b5371931341c">ExecuteScheduled</a> (const std::vector&lt; <a class="el" href="structSchedulers_1_1ExecuteCircuit.html">Schedulers::ExecuteCircuit</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;circuits)=0</td></tr>
<tr class="memdesc:a5e8996656e5c376f82c9b5371931341c inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule and execute circuits on the network.  <br /></td></tr>
<tr class="memitem:a231e5f0a714696312629cf70dc7ca44f inherit pub_methods_classNetwork_1_1INetwork" id="r_a231e5f0a714696312629cf70dc7ca44f"><td class="memItemLeft">virtual bool&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a231e5f0a714696312629cf70dc7ca44f">IsLocalOperation</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;op) const=0</td></tr>
<tr class="memdesc:a231e5f0a714696312629cf70dc7ca44f inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the circuit operation is local.  <br /></td></tr>
<tr class="memitem:a1a2210a0f608a6ac6ed8e87348cc85c2 inherit pub_methods_classNetwork_1_1INetwork" id="r_a1a2210a0f608a6ac6ed8e87348cc85c2"><td class="memItemLeft">virtual bool&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a1a2210a0f608a6ac6ed8e87348cc85c2">IsDistributedOperation</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;op) const=0</td></tr>
<tr class="memdesc:a1a2210a0f608a6ac6ed8e87348cc85c2 inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the circuit operation is distributed.  <br /></td></tr>
<tr class="memitem:a89e9d9a4b65450bacdf43cc3fe0faba2 inherit pub_methods_classNetwork_1_1INetwork" id="r_a89e9d9a4b65450bacdf43cc3fe0faba2"><td class="memItemLeft">virtual bool&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a89e9d9a4b65450bacdf43cc3fe0faba2">OperatesWithNetworkEntangledQubit</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;op) const=0</td></tr>
<tr class="memdesc:a89e9d9a4b65450bacdf43cc3fe0faba2 inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the circuit operation operates on the entanglement qubits between hosts.  <br /></td></tr>
<tr class="memitem:a7940ce3090852de2fd9543bbc3292eb8 inherit pub_methods_classNetwork_1_1INetwork" id="r_a7940ce3090852de2fd9543bbc3292eb8"><td class="memItemLeft">virtual bool&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a7940ce3090852de2fd9543bbc3292eb8">IsEntanglingGate</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;op) const=0</td></tr>
<tr class="memdesc:a7940ce3090852de2fd9543bbc3292eb8 inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a gate is an entangling gate.  <br /></td></tr>
<tr class="memitem:a22b353be6b1743c4d2cdd920bbbc180c inherit pub_methods_classNetwork_1_1INetwork" id="r_a22b353be6b1743c4d2cdd920bbbc180c"><td class="memItemLeft">virtual bool&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a22b353be6b1743c4d2cdd920bbbc180c">ExpectsClassicalBitFromOtherHost</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;op) const=0</td></tr>
<tr class="memdesc:a22b353be6b1743c4d2cdd920bbbc180c inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a gate expects a classical bit from another host.  <br /></td></tr>
<tr class="memitem:a9ef908e8ff8166d4c3740389033748cd inherit pub_methods_classNetwork_1_1INetwork" id="r_a9ef908e8ff8166d4c3740389033748cd"><td class="memItemLeft">virtual size_t&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a9ef908e8ff8166d4c3740389033748cd">GetHostIdForClassicalControl</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;op) const=0</td></tr>
<tr class="memdesc:a9ef908e8ff8166d4c3740389033748cd inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the host id where the classical control bit resides for a conditioned gate.  <br /></td></tr>
<tr class="memitem:a75e453a585ee0cc245b7f8b45495c944 inherit pub_methods_classNetwork_1_1INetwork" id="r_a75e453a585ee0cc245b7f8b45495c944"><td class="memItemLeft">std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a75e453a585ee0cc245b7f8b45495c944">getptr</a> ()</td></tr>
<tr class="memdesc:a75e453a585ee0cc245b7f8b45495c944 inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a shared pointer to this object.  <br /></td></tr>
<tr class="memitem:ad13d2d4aa5bfe7c3379434d5f1a65b83 inherit pub_methods_classNetwork_1_1INetwork" id="r_ad13d2d4aa5bfe7c3379434d5f1a65b83"><td class="memItemLeft">virtual std::vector&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#ad13d2d4aa5bfe7c3379434d5f1a65b83">GetSubroutinesTextCode</a> () const</td></tr>
<tr class="memdesc:ad13d2d4aa5bfe7c3379434d5f1a65b83 inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the text code that is executed on the hosts.  <br /></td></tr>
<tr class="memitem:a0165dd5bbd0ecafd731da8eab599b7bc inherit pub_methods_classNetwork_1_1INetwork" id="r_a0165dd5bbd0ecafd731da8eab599b7bc"><td class="memItemLeft">virtual std::shared_ptr&lt; <a class="el" href="classSimulators_1_1ISimulator.html">Simulators::ISimulator</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1INetwork.html#a0165dd5bbd0ecafd731da8eab599b7bc">ChooseBestSimulator</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;dcirc, size_t &amp;counts, size_t nrQubits, size_t nrCbits, size_t nrResultCbits, <a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a> &amp;simType, <a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a> &amp;method, std::vector&lt; bool &gt; &amp;executed, bool multithreading=false, bool dontRunCircuitStart=false) const=0</td></tr>
<tr class="memdesc:a0165dd5bbd0ecafd731da8eab599b7bc inherit pub_methods_classNetwork_1_1INetwork"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose the best simulator for the given circuit.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a92e664133827b49a7bce728b5e2c259d" id="r_a92e664133827b49a7bce728b5e2c259d"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a92e664133827b49a7bce728b5e2c259d">ConvertBackState</a> ()</td></tr>
<tr class="memdesc:a92e664133827b49a7bce728b5e2c259d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts back the state from the optimized network distribution mapping.  <br /></td></tr>
<tr class="memitem:af42d7a8553d465f0da144606c73fd8ae" id="r_af42d7a8553d465f0da144606c73fd8ae"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#af42d7a8553d465f0da144606c73fd8ae">ConvertBackState</a> (const std::unordered_map&lt; <a class="el" href="namespaceTypes.html#afda27b666a29ff2e858b10ee1a7e4b73">Types::qubit_t</a>, <a class="el" href="namespaceTypes.html#afda27b666a29ff2e858b10ee1a7e4b73">Types::qubit_t</a> &gt; &amp;qubitsMap)</td></tr>
<tr class="memdesc:af42d7a8553d465f0da144606c73fd8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts back the state using the passed qubits map.  <br /></td></tr>
<tr class="memitem:adcf9c52784263ced045859e257fbfd6d" id="r_adcf9c52784263ced045859e257fbfd6d"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#adcf9c52784263ced045859e257fbfd6d">ConvertBackResults</a> (<a class="el" href="#a1537dfd62f404ccfbfd5cebf9e87b5ae">ExecuteResults</a> &amp;res)</td></tr>
<tr class="memdesc:adcf9c52784263ced045859e257fbfd6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts back the results from the optimized network distribution mapping.  <br /></td></tr>
<tr class="memitem:a925503f6c758f74a5d46a1ff2e90e971" id="r_a925503f6c758f74a5d46a1ff2e90e971"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a925503f6c758f74a5d46a1ff2e90e971">ConvertBackResults</a> (<a class="el" href="#a1537dfd62f404ccfbfd5cebf9e87b5ae">ExecuteResults</a> &amp;res, const std::unordered_map&lt; <a class="el" href="namespaceTypes.html#afda27b666a29ff2e858b10ee1a7e4b73">Types::qubit_t</a>, <a class="el" href="namespaceTypes.html#afda27b666a29ff2e858b10ee1a7e4b73">Types::qubit_t</a> &gt; &amp;bitsMap) const</td></tr>
<tr class="memdesc:a925503f6c758f74a5d46a1ff2e90e971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts back the results using the passed qubits map.  <br /></td></tr>
<tr class="memitem:a211b84ee9b5cc93d6aa4a72e06533dc1" id="r_a211b84ee9b5cc93d6aa4a72e06533dc1"><td class="memItemLeft">std::unordered_map&lt; <a class="el" href="namespaceTypes.html#afda27b666a29ff2e858b10ee1a7e4b73">Types::qubit_t</a>, <a class="el" href="namespaceTypes.html#afda27b666a29ff2e858b10ee1a7e4b73">Types::qubit_t</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a211b84ee9b5cc93d6aa4a72e06533dc1">MapCircuitOnHost</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit, size_t hostId, size_t &amp;nrQubits, size_t &amp;nrCbits, bool useSeparateSimForHosts=false)</td></tr>
<tr class="memdesc:a211b84ee9b5cc93d6aa4a72e06533dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the circuit on the host.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-attribs" class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2da42e0d0e4f7269e549cc9bcdbd489b" id="r_a2da42e0d0e4f7269e549cc9bcdbd489b"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a2da42e0d0e4f7269e549cc9bcdbd489b">optimizeSimulator</a> = true</td></tr>
<tr class="memdesc:a2da42e0d0e4f7269e549cc9bcdbd489b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The flag to optimize the simulator.  <br /></td></tr>
<tr class="memitem:a7c1824a218d3ec95663bb8642f5f894c" id="r_a7c1824a218d3ec95663bb8642f5f894c"><td class="memItemLeft"><a class="el" href="classNetwork_1_1INetwork.html#aa948773ddeeadbf03487095c5ac1da11">BaseClass::SimulatorsSet</a>&#160;</td><td class="memItemRight"><a class="el" href="#a7c1824a218d3ec95663bb8642f5f894c">simulatorsForOptimizations</a></td></tr>
<tr class="memitem:a03602197482a8ab5f3af8efd44d07e20" id="r_a03602197482a8ab5f3af8efd44d07e20"><td class="memItemLeft"><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a>&#160;</td><td class="memItemRight"><a class="el" href="#a03602197482a8ab5f3af8efd44d07e20">lastSimulatorType</a></td></tr>
<tr class="memdesc:a03602197482a8ab5f3af8efd44d07e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last simulator type used.  <br /></td></tr>
<tr class="memitem:a2c15255689087b24bfebe41e385b273c" id="r_a2c15255689087b24bfebe41e385b273c"><td class="memItemLeft"><a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a>&#160;</td><td class="memItemRight"><a class="el" href="#a2c15255689087b24bfebe41e385b273c">lastMethod</a></td></tr>
<tr class="memdesc:a2c15255689087b24bfebe41e385b273c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last simulation method used.  <br /></td></tr>
<tr class="memitem:a02320f596d00f3b51716656a1900d080" id="r_a02320f596d00f3b51716656a1900d080"><td class="memItemLeft">std::string&#160;</td><td class="memItemRight"><a class="el" href="#a02320f596d00f3b51716656a1900d080">maxBondDim</a></td></tr>
<tr class="memitem:a0a4873717a9c027efeb5be2f680652f8" id="r_a0a4873717a9c027efeb5be2f680652f8"><td class="memItemLeft">std::string&#160;</td><td class="memItemRight"><a class="el" href="#a0a4873717a9c027efeb5be2f680652f8">singularValueThreshold</a></td></tr>
<tr class="memitem:ab096a7d8b912200b36f81e4c3571aa1c" id="r_ab096a7d8b912200b36f81e4c3571aa1c"><td class="memItemLeft">std::string&#160;</td><td class="memItemRight"><a class="el" href="#ab096a7d8b912200b36f81e4c3571aa1c">mpsSample</a></td></tr>
<tr class="memitem:ada9b6cba5dab37d06d39e86f0863b7ce" id="r_ada9b6cba5dab37d06d39e86f0863b7ce"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#ada9b6cba5dab37d06d39e86f0863b7ce">maxSimulators</a></td></tr>
<tr class="memdesc:ada9b6cba5dab37d06d39e86f0863b7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of simulators that can be used in the network.  <br /></td></tr>
<tr class="memitem:a905d6430ef17c214477c64e6c4f219a0" id="r_a905d6430ef17c214477c64e6c4f219a0"><td class="memItemLeft"><a class="el" href="classCircuits_1_1OperationState.html">Circuits::OperationState</a>&#160;</td><td class="memItemRight"><a class="el" href="#a905d6430ef17c214477c64e6c4f219a0">classicalState</a></td></tr>
<tr class="memdesc:a905d6430ef17c214477c64e6c4f219a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The classical state of the network.  <br /></td></tr>
<tr class="memitem:a06785803127fbf6c85d43dbc61d2f603" id="r_a06785803127fbf6c85d43dbc61d2f603"><td class="memItemLeft">std::shared_ptr&lt; <a class="el" href="classSimulators_1_1ISimulator.html">Simulators::ISimulator</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a06785803127fbf6c85d43dbc61d2f603">simulator</a></td></tr>
<tr class="memdesc:a06785803127fbf6c85d43dbc61d2f603"><td class="mdescLeft">&#160;</td><td class="mdescRight">The quantum computing simulator for the network.  <br /></td></tr>
<tr class="memitem:a9a2125d19b5cf1b55e373e661e32f0aa" id="r_a9a2125d19b5cf1b55e373e661e32f0aa"><td class="memItemLeft">std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a9a2125d19b5cf1b55e373e661e32f0aa">distCirc</a></td></tr>
<tr class="memdesc:a9a2125d19b5cf1b55e373e661e32f0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The distributed circuit.  <br /></td></tr>
<tr class="memitem:adb92ba31d3aff643374bd30da93805c9" id="r_adb92ba31d3aff643374bd30da93805c9"><td class="memItemLeft">std::shared_ptr&lt; <a class="el" href="classNetwork_1_1IController.html">IController</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#adb92ba31d3aff643374bd30da93805c9">controller</a></td></tr>
<tr class="memdesc:adb92ba31d3aff643374bd30da93805c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The controller for the network.  <br /></td></tr>
<tr class="memitem:a7bb91682710357f62cbba79c36c07ed4" id="r_a7bb91682710357f62cbba79c36c07ed4"><td class="memItemLeft">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classNetwork_1_1IHost.html">IHost</a>&lt; Time &gt; &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a7bb91682710357f62cbba79c36c07ed4">hosts</a></td></tr>
<tr class="memdesc:a7bb91682710357f62cbba79c36c07ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The hosts in the network.  <br /></td></tr>
<tr class="memitem:a40a5c222e5241b6dcbee325c48ec8acb" id="r_a40a5c222e5241b6dcbee325c48ec8acb"><td class="memItemLeft">std::unique_ptr&lt; <a class="el" href="classEstimators_1_1SimulatorsEstimatorInterface.html">Estimators::SimulatorsEstimatorInterface</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a40a5c222e5241b6dcbee325c48ec8acb">simulatorsEstimator</a></td></tr>
<tr class="memdesc:a40a5c222e5241b6dcbee325c48ec8acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The simulators estimator.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt;<br />
class Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</div><p>The simple network implementation. </p>
<p>The simple network implementation. A simple network class, implementing a network containing a buch of hosts, no communication (classical or quantum) among them.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Time</td><td>The time type used for execution times. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNetwork_1_1INetwork.html" title="The network interface.">INetwork</a> </dd>
<dd>
<a class="el" href="classNetwork_1_1SimpleController.html" title="The simple controller host implementation.">SimpleController</a> </dd>
<dd>
<a class="el" href="classNetwork_1_1SimpleHost.html" title="The simple host implementation.">SimpleHost</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00042">42</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="ada086141239589722e9b4753ed4ed73d" name="ada086141239589722e9b4753ed4ed73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada086141239589722e9b4753ed4ed73d">&#9670;&#160;</a></span>BaseClass</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::BaseClass = <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt;Time&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The base class type. </p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00044">44</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a1537dfd62f404ccfbfd5cebf9e87b5ae" name="a1537dfd62f404ccfbfd5cebf9e87b5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1537dfd62f404ccfbfd5cebf9e87b5ae">&#9670;&#160;</a></span>ExecuteResults</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::ExecuteResults</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">typename</span> <a class="code hl_typedef" href="classNetwork_1_1INetwork.html#aa7e4e730dac51e0ae031528ecdfe7378">BaseClass::ExecuteResults</a></div>
<div class="ttc" id="aclassNetwork_1_1INetwork_html_aa7e4e730dac51e0ae031528ecdfe7378"><div class="ttname"><a href="classNetwork_1_1INetwork.html#aa7e4e730dac51e0ae031528ecdfe7378">Network::INetwork&lt; Time &gt;::ExecuteResults</a></div><div class="ttdeci">typename Circuits::Circuit&lt; Time &gt;::ExecuteResults ExecuteResults</div><div class="ttdef"><b>Definition</b> <a href="Network_8h_source.html#l00058">Network.h:58</a></div></div>
</div><!-- fragment -->
<p>The execute results type. </p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00045">45</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af23afa210e1774159a5517151a6ed410" name="af23afa210e1774159a5517151a6ed410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23afa210e1774159a5517151a6ed410">&#9670;&#160;</a></span>SimpleDisconnectedNetwork()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::SimpleDisconnectedNetwork </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceTypes.html#afda27b666a29ff2e858b10ee1a7e4b73">Types::qubit_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>qubits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cbits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constructor. </p>
<p>Constructs the simple network object, creating the network hosts and the controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubits</td><td>The number of qubits for each host. </td></tr>
    <tr><td class="paramname">cbits</td><td>The number of classical bits for each host. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00057">57</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a2424468039a56fa0b6d96604db08f828" name="a2424468039a56fa0b6d96604db08f828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2424468039a56fa0b6d96604db08f828">&#9670;&#160;</a></span>AddOptimizationSimulator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::AddOptimizationSimulator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a></td>          <td class="paramname"><span class="paramname"><em>kind</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a simulator to the simulators optimization set. </p>
<p>Adds a simulator (if not already present) to the simulators optimization set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the simulator to add. </td></tr>
    <tr><td class="paramname">kind</td><td>The kind of the simulation to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a752bdbaa3348d82f8362c6ae874e5337">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01633">1633</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="afd15438f447aea77b9fb2a548fc822a8" name="afd15438f447aea77b9fb2a548fc822a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd15438f447aea77b9fb2a548fc822a8">&#9670;&#160;</a></span>AreClassicalBitsOnSameHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::AreClassicalBitsOnSameHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bitId1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bitId2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the specified classical bits are on the same host. </p>
<p>Check if the specified classical are on the same host. This does not include the classical bits used for measuring the qubits used for entanglement between the hosts.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the specified qubits are on the same host, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#ad8bf9a776bba8f30a97f49f80d58eb6d">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01257">1257</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="ad78a8a5a095c7a67c151b91817baffd0" name="ad78a8a5a095c7a67c151b91817baffd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78a8a5a095c7a67c151b91817baffd0">&#9670;&#160;</a></span>AreEntanglementQubitsBusy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::AreEntanglementQubitsBusy </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if any of the two specified qubits used for entanglement between hosts are busy. </p>
<p>Check if any of the two specified qubits used for entanglement between hosts are busy. This is used to check if the qubits are free in order to use them for creating an entanglement between hosts. It's not used in the simple network, because it doesn't allow quantum communication between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubitId1</td><td>The id of the first qubit to check. </td></tr>
    <tr><td class="paramname">qubitId2</td><td>The id of the second qubit to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any of the two specified qubits used for entanglement between hosts are busy, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a693f4ba4a976500057608bb3ff589d2e">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01470">1470</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a6bfc7fbb149632fdf31a0233461e2293" name="a6bfc7fbb149632fdf31a0233461e2293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfc7fbb149632fdf31a0233461e2293">&#9670;&#160;</a></span>AreQubitAndClassicalBitOnSameHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::AreQubitAndClassicalBitOnSameHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bitId</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the specified qubit and classical bit are on the same host. </p>
<p>Check if the specified qubit and classical bit are on the same host. This does not include the qubits used for entanglement between the hosts and the classical bits used for their measurement.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the specified qubit and classical bit are on the same host, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#aa0c6505b65db2babf16a3f2c9f8d6a00">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01281">1281</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a8097c7e6113ae3df223b56791f69db20" name="a8097c7e6113ae3df223b56791f69db20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8097c7e6113ae3df223b56791f69db20">&#9670;&#160;</a></span>AreQubitsOnSameHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::AreQubitsOnSameHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the specified qubits are on the same host. </p>
<p>Check if the specified qubits are on the same host. This does not include the qubits used for entanglement between the hosts.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the specified qubits are on the same host, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a59bb55fcc09c35d5aa1c21f5ad2249d1">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01234">1234</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a95bce95dcc734c6c03a9bc8eebcaa279" name="a95bce95dcc734c6c03a9bc8eebcaa279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bce95dcc734c6c03a9bc8eebcaa279">&#9670;&#160;</a></span>ChooseBestSimulator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classSimulators_1_1ISimulator.html">Simulators::ISimulator</a> &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::ChooseBestSimulator </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dcirc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>counts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nrQubits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nrCbits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nrResultCbits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>simType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>method</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>executed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>multithreading</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>dontRunCircuitStart</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01722">1722</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="adc457460c0cd933d072808da878b271e" name="adc457460c0cd933d072808da878b271e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc457460c0cd933d072808da878b271e">&#9670;&#160;</a></span>ClearEntanglements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::ClearEntanglements </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all entanglements between hosts in the network. </p>
<p>Clear all entanglements between hosts in the network. This marks all qubits used for entanglement between hosts as free. If the entanglements are explicitely coordinated in the network, all pairs of entangled qubits are released. It's not used in the simple network, because it doesn't allow quantum communication between hosts. </p>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a15a187cbee6f0fbea202ce73e8a4e90d">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01517">1517</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a5b1a1277feaaad66db284db1f7fe1569" name="a5b1a1277feaaad66db284db1f7fe1569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1a1277feaaad66db284db1f7fe1569">&#9670;&#160;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::Clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone the network. </p>
<p>Clone the network in a pristine state. </p><dl class="section return"><dt>Returns</dt><dd>A shared pointer to the cloned network. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a9dc2a3747334f094ca63c4ad9741bbb2">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01693">1693</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a3beaae2be8da41f5362532960cf984aa" name="a3beaae2be8da41f5362532960cf984aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3beaae2be8da41f5362532960cf984aa">&#9670;&#160;</a></span>Configure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::Configure </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configures the network. </p>
<p>This function is called to configure the network (for example the <a class="el" href="#a06785803127fbf6c85d43dbc61d2f603" title="The quantum computing simulator for the network.">simulator(s)</a> used by the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the configuration option. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the configuration. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a79ac17adf81c745de120e19b78a1743c">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00809">809</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="adcf9c52784263ced045859e257fbfd6d" name="adcf9c52784263ced045859e257fbfd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf9c52784263ced045859e257fbfd6d">&#9670;&#160;</a></span>ConvertBackResults() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::ConvertBackResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1537dfd62f404ccfbfd5cebf9e87b5ae">ExecuteResults</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>res</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts back the results from the optimized network distribution mapping. </p>
<p>Converts back the results from the optimized network distribution mapping. It's used only if there is an optimiser set, that is, there was a rempapping/optimizing of the circuit to be distributed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The results to convert back. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01922">1922</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a925503f6c758f74a5d46a1ff2e90e971" name="a925503f6c758f74a5d46a1ff2e90e971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925503f6c758f74a5d46a1ff2e90e971">&#9670;&#160;</a></span>ConvertBackResults() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::ConvertBackResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1537dfd62f404ccfbfd5cebf9e87b5ae">ExecuteResults</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; <a class="el" href="namespaceTypes.html#afda27b666a29ff2e858b10ee1a7e4b73">Types::qubit_t</a>, <a class="el" href="namespaceTypes.html#afda27b666a29ff2e858b10ee1a7e4b73">Types::qubit_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bitsMap</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts back the results using the passed qubits map. </p>
<p>Converts back the results using the passed qubits map It's used only if there is an optimiser set, that is, there was a rempapping/optimizing of the circuit to be distributed. Or if there is an execution on a single host and the passed circuit had a different mapping for qubits than the host qubits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The results to convert back. </td></tr>
    <tr><td class="paramname">bitsMap</td><td>The map with the bits mapping. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01944">1944</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a92e664133827b49a7bce728b5e2c259d" name="a92e664133827b49a7bce728b5e2c259d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e664133827b49a7bce728b5e2c259d">&#9670;&#160;</a></span>ConvertBackState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::ConvertBackState </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts back the state from the optimized network distribution mapping. </p>
<p>Converts back the state from the optimized network distribution mapping. It's used only if there is an optimiser set, that is, there was a rempapping/optimizing of the circuit to be distributed. </p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01883">1883</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="af42d7a8553d465f0da144606c73fd8ae" name="af42d7a8553d465f0da144606c73fd8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42d7a8553d465f0da144606c73fd8ae">&#9670;&#160;</a></span>ConvertBackState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::ConvertBackState </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; <a class="el" href="namespaceTypes.html#afda27b666a29ff2e858b10ee1a7e4b73">Types::qubit_t</a>, <a class="el" href="namespaceTypes.html#afda27b666a29ff2e858b10ee1a7e4b73">Types::qubit_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>qubitsMap</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts back the state using the passed qubits map. </p>
<p>Converts back the state using the passed qubits map. It's used only if there is an optimiser set, that is, there was a rempapping/optimizing of the circuit to be distributed. Or if there is an execution on a single host and the passed circuit had a different mapping for qubits than the host qubits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubitsMap</td><td>The map with the qubits mapping. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01904">1904</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="af1d1a2dfa2db52516640d7324487d55d" name="af1d1a2dfa2db52516640d7324487d55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d1a2dfa2db52516640d7324487d55d">&#9670;&#160;</a></span>CreateNetwork()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::CreateNetwork </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceTypes.html#afda27b666a29ff2e858b10ee1a7e4b73">Types::qubit_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>qubits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cbits</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the network hosts and controller. </p>
<p>Creates the network hosts and controller with the specified number of qubits and classical bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubits</td><td>The number of qubits for each host. </td></tr>
    <tr><td class="paramname">cbits</td><td>The number of classical bits for each host. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00071">71</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="ac5c495840beeaa043b4b7ec85cd18bb7" name="ac5c495840beeaa043b4b7ec85cd18bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c495840beeaa043b4b7ec85cd18bb7">&#9670;&#160;</a></span>CreateScheduler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::CreateScheduler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1">SchedulerType</a></td>          <td class="paramname"><span class="paramname"><em>schType</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1ab90c9b48118b61527e8d21a4bb699c4b">SchedulerType::kNoEntanglementQubitsParallel</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the scheduler for the network. </p>
<p>Creates the scheduler for the network. Call this only after the network topology has been set up. Should create the scheduler and set the network for it and any other necessary parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simType</td><td>The type of the scheduler to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1" title="The type of the network scheduler for scheduling execution of multiple circuits.">SchedulerType</a> </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#aad379273cb76f8c2e734fcad6010950e">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00857">857</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a3eee70024a100f2d13da135e4fc94214" name="a3eee70024a100f2d13da135e4fc94214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eee70024a100f2d13da135e4fc94214">&#9670;&#160;</a></span>CreateSimulator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::CreateSimulator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a></td>          <td class="paramname"><span class="paramname"><em>simType</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aaa20dd7a84a53e5ace6f43951e3f0b0337">Simulators::SimulatorType::kQCSim</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a></td>          <td class="paramname"><span class="paramname"><em>simExecType</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789a62f6eb80f4ebe16a28e8405dffac7fea">Simulators::SimulationType::kMatrixProductState</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nrQubits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the simulator for the network. </p>
<p>Creates the simulator for the network. Call this only after the network topology has been set up. Should create the simulator with the proper number of qubits for the whole network and also set up a 'classical state' for the whole network and distribute the qubits and cbits to the hosts. The nrQubits parameter is used internally to allocate a simulator for a single host only - if a circuit is executed on a single host. Let it to the default value - 0 - to allocate the number of qubits for the whole network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simType</td><td>The type of the simulator to create. </td></tr>
    <tr><td class="paramname">simExecType</td><td>The type of the simulation - statevector, composite, matrix product state, stabilizer, tensor network... </td></tr>
    <tr><td class="paramname">nrQubits</td><td>The number of qubits to allocate for the simulator. Default is 0 - allocate the number of qubits for the whole network. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa" title="The type of simulator.">Simulators::SimulatorType</a> </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a8e6daa8026a734401c90514b76f12044">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00771">771</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a76c5d531223dad99ee8c48f4695e0107" name="a76c5d531223dad99ee8c48f4695e0107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c5d531223dad99ee8c48f4695e0107">&#9670;&#160;</a></span>Execute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::Execute </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the circuit on the network. </p>
<p>Execute the circuit on the network, using the controller for distributing the operations to the hosts. Ensure the quantum computing simulator has been created before calling this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuit</td><td>The circuit to execute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00107">107</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a02f42154e8fba4d72caa9b37b35a0a41" name="a02f42154e8fba4d72caa9b37b35a0a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f42154e8fba4d72caa9b37b35a0a41">&#9670;&#160;</a></span>ExecuteExpectations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::ExecuteExpectations </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>paulis</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the circuit on the network and return the expectation values for the specified Pauli strings. </p>
<p>Execute the circuit on the network, using the controller for distributing the operations to the hosts and return the expectation values for the specified Pauli strings. The base class functionality is used for circuit distribution, but then the distributed circuit is converted to netqasm. Ensure the quantum computing simulator and the netqasm virtual machines have been created before calling this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuit</td><td>The circuit to execute. </td></tr>
    <tr><td class="paramname">paulis</td><td>The Pauli strings to measure the expectations for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00200">200</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a10a2aa943a0bd764a2edc61972ccf5e2" name="a10a2aa943a0bd764a2edc61972ccf5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a2aa943a0bd764a2edc61972ccf5e2">&#9670;&#160;</a></span>ExecuteOnHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::ExecuteOnHost </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the circuit on the specified host. </p>
<p>Execute the circuit on the specified host. The circuit must fit on the host, otherwise an exception is thrown. The circuit will be mapped on the specified host, if its qubits start with indexing from 0 (if already mapped, the qubits won't be altered).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuit</td><td>The circuit to execute. </td></tr>
    <tr><td class="paramname">hostId</td><td>The id of the host to execute the circuit on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00152">152</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a94d87f73b94d27595cde311c846d1e21" name="a94d87f73b94d27595cde311c846d1e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d87f73b94d27595cde311c846d1e21">&#9670;&#160;</a></span>ExecuteOnHostExpectations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::ExecuteOnHostExpectations </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>paulis</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the circuit on the specified host and return the expectation values for the specified Pauli strings. </p>
<p>Execute the circuit on the specified host and return the expectation values for the specified Pauli strings. The circuit must fit on the host, otherwise an exception is thrown. The circuit will be mapped on the specified host, if its qubits start with indexing from 0 (if already mapped, the qubits won't be altered).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuit</td><td>The circuit to execute. </td></tr>
    <tr><td class="paramname">hostId</td><td>The id of the host to execute the circuit on. </td></tr>
    <tr><td class="paramname">paulis</td><td>The Pauli strings to measure the expectations for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00280">280</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a837a373546b78cc3f1a2da25204f9081" name="a837a373546b78cc3f1a2da25204f9081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837a373546b78cc3f1a2da25204f9081">&#9670;&#160;</a></span>ExecuteScheduled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="#a1537dfd62f404ccfbfd5cebf9e87b5ae">ExecuteResults</a> &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::ExecuteScheduled </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structSchedulers_1_1ExecuteCircuit.html">Schedulers::ExecuteCircuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuits</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedule and execute circuits on the network. </p>
<p>Execute the circuits on the network, scheduling their execution and distributing the operations to the hosts. The way the circuits are distributed to the hosts depends on the specific interface implementations. The way they are scheduled depends on the network scheduler and parametrization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuits</td><td>The circuits to execute, along with the number of shots. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of maps with the results of each circuit execution, where the key is the state as a vector of bools and the value is the number of times it was measured. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd>
<dd>
ExecuteCircuit </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00740">740</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a0c8dfc900846394f7676ac3a5bb59193" name="a0c8dfc900846394f7676ac3a5bb59193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8dfc900846394f7676ac3a5bb59193">&#9670;&#160;</a></span>ExpectsClassicalBitFromOtherHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::ExpectsClassicalBitFromOtherHost </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a gate expects a classical bit from another host. </p>
<p>It must be a conditional gate, conditioned on a classical bit from another host. Use it on already distributed gates, not on the original circuit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified circuit operation needs a classical bit from another host, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01175">1175</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="ac7f34eee1300e60156c75471bd7cdcda" name="ac7f34eee1300e60156c75471bd7cdcda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f34eee1300e60156c75471bd7cdcda">&#9670;&#160;</a></span>GetClassicalBitsIds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetClassicalBitsIds </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the classical bit ids for the specified host. </p>
<p>Get the classical bit ids for the specified host, excluding the one(s) used for measurement of entanglemen qubits between the hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostId</td><td>The id of the host to get the classical bit ids for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with the classical bit ids. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a32a22cf71a50794f6cebffb8041e18f7">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01403">1403</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="aaaef4e5472e4dd6cc177c5a26a408622" name="aaaef4e5472e4dd6cc177c5a26a408622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaef4e5472e4dd6cc177c5a26a408622">&#9670;&#160;</a></span>GetController()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1IController.html">IController</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetController </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the controller for the network. </p>
<p>Gets a smart pointer to the controller for the network.</p>
<dl class="section return"><dt>Returns</dt><dd>The controller for the network. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNetwork_1_1IController.html" title="The controller host interface.">IController</a> </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#af7014ccd32005ed57052893c1973c877">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00902">902</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a3128d73e5b2c2a35571b7413a83bd48f" name="a3128d73e5b2c2a35571b7413a83bd48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3128d73e5b2c2a35571b7413a83bd48f">&#9670;&#160;</a></span>GetDistributedCircuit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetDistributedCircuit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the distributed circuit. </p>
<p>Get the distributed circuit. <a class="el" href="#a76c5d531223dad99ee8c48f4695e0107" title="Execute the circuit on the network.">Execute()</a> must be called first, otherwise the return would be nullptr.</p>
<dl class="section return"><dt>Returns</dt><dd>The distributed circuit. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a9de72cfe3605bdb7afba76993195ce9b">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01531">1531</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="ac8499d79e66d8bc04d140d28f7e415d2" name="ac8499d79e66d8bc04d140d28f7e415d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8499d79e66d8bc04d140d28f7e415d2">&#9670;&#160;</a></span>GetEntangledQubitMeasurementBitIds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetEntangledQubitMeasurementBitIds </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the classical bit ids used for measurement of entanglement qubits between the hosts for the specified host. </p>
<p>Get the classical bit ids used for measurement of entanglement qubits between the hosts for the specified host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostId</td><td>The id of the host to get the classical bit ids for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with the classical bit ids. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#ae707d7266464fe11cd168a3b29de2250">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01419">1419</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a4190672a3cbcc56a3daacd93555007a8" name="a4190672a3cbcc56a3daacd93555007a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4190672a3cbcc56a3daacd93555007a8">&#9670;&#160;</a></span>GetHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1IHost.html">IHost</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the host with the specified id. </p>
<p>Get a smart pointer to the host that has the specified id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostId</td><td>The id of the host to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the host that has the specified id. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNetwork_1_1IHost.html" title="The host interface.">IHost</a> </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a87e1848fa60b03837f25819af4b7a421">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00888">888</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a87b8db81eb036b773c0adf1875634540" name="a87b8db81eb036b773c0adf1875634540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b8db81eb036b773c0adf1875634540">&#9670;&#160;</a></span>GetHostIdForAnyQubit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetHostIdForAnyQubit </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the host id for the specified qubit. </p>
<p>Get the host id for the squbit, including the qubits used for entanglement between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubitId</td><td>The id of the qubit to get the host id for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The host id for the specified qubit. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a2f22f9d7758999f2d318b2d11b4ad5f0">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01340">1340</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a36976d5eac2433ba03bf309280d75ce5" name="a36976d5eac2433ba03bf309280d75ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36976d5eac2433ba03bf309280d75ce5">&#9670;&#160;</a></span>GetHostIdForClassicalBit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetHostIdForClassicalBit </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>classicalBitId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the host id for the specified classical bit. </p>
<p>Get the host id for the specified classical bit, excluding the one(s) used for measurement of entanglement qubits between the hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">classicalBitId</td><td>The id of the classical bit to get the host id for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The host id for the specified classical bit. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#affc2d3e3400bd8246e576a97c829a42c">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01356">1356</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a1219ee350c2b7b06f1fa40b6c054211a" name="a1219ee350c2b7b06f1fa40b6c054211a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1219ee350c2b7b06f1fa40b6c054211a">&#9670;&#160;</a></span>GetHostIdForClassicalControl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetHostIdForClassicalControl </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the host id where the classical control bit resides for a conditioned gate. </p>
<p>It must be a conditional gate, conditioned on a qubit from another host. Use it on already distributed gates, not on the original circuit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to find the host of the control bit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The host id. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01211">1211</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a04384bbfdd7970e4e4834efa873a6d4f" name="a04384bbfdd7970e4e4834efa873a6d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04384bbfdd7970e4e4834efa873a6d4f">&#9670;&#160;</a></span>GetHostIdForEntangledQubit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetHostIdForEntangledQubit </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the host id for the specified qubit used for entanglement between hosts. </p>
<p>Get the host id for the specified qubit used for entanglement between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubitId</td><td>The id of the qubit used for entanglement between hosts to get the host id for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The host id for the specified qubit used for entanglement between hosts. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#ab6ba8cc6b58268fba46720be9f0adb20">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01324">1324</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a4e1c0079ea5ccd1aba336ac04514f2b8" name="a4e1c0079ea5ccd1aba336ac04514f2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1c0079ea5ccd1aba336ac04514f2b8">&#9670;&#160;</a></span>GetHostIdForQubit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetHostIdForQubit </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the host id for the specified qubit. </p>
<p>Get the host id for the specified qubit, excluding the qubits used for entanglement between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubitId</td><td>The id of the qubit to get the host id for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The host id for the specified qubit. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#ab6bc597ecc0cd7adbfd5b7b400c1d079">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01305">1305</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="aafc29ca8168432221397e765410e2836" name="aafc29ca8168432221397e765410e2836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc29ca8168432221397e765410e2836">&#9670;&#160;</a></span>GetHosts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classNetwork_1_1IHost.html">IHost</a>&lt; Time &gt; &gt; &gt; &amp; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetHosts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the hosts in the network. </p>
<p>Gets the hosts in the network.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector with the hosts in the network. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNetwork_1_1IHost.html" title="The host interface.">IHost</a> </dd>
<dd>
<a class="el" href="classNetwork_1_1SimpleHost.html" title="The simple host implementation.">SimpleHost</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01022">1022</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a6492ca625156136c2e438083093b2ef7" name="a6492ca625156136c2e438083093b2ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6492ca625156136c2e438083093b2ef7">&#9670;&#160;</a></span>GetLastSimulationType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a> <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetLastSimulationType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last used simulation type. </p>
<p>Get the last used simulation type.</p>
<dl class="section return"><dt>Returns</dt><dd>The simulation type that was used last time. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a05c53ae7f147e63c95cd33dfcd465bb7">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01554">1554</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a02697dcb575dadb6060ca5d60ccdeffd" name="a02697dcb575dadb6060ca5d60ccdeffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02697dcb575dadb6060ca5d60ccdeffd">&#9670;&#160;</a></span>GetLastSimulatorType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a> <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetLastSimulatorType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last used simulator type. </p>
<p>Get the last used simulator type.</p>
<dl class="section return"><dt>Returns</dt><dd>The simulator type that was used last time. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#ab3bc4744d3a0c79ef13f07b33332fce2">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01543">1543</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="ac384bc3121527e1334aa886ebb21fb87" name="ac384bc3121527e1334aa886ebb21fb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac384bc3121527e1334aa886ebb21fb87">&#9670;&#160;</a></span>GetMaxSimulators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetMaxSimulators </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum number of simulators that can be used in the network. </p>
<p>Get the maximum number of simulators that can be used in the network. This is used to limit the number of simulators (and corresponding threads) that can be used in the network.</p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of simulators that can be used in the network. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a52d7eeb7fcc89b7937443a12a8bbd84a">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01568">1568</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="af346a968922fed1b2607879c69616499" name="af346a968922fed1b2607879c69616499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af346a968922fed1b2607879c69616499">&#9670;&#160;</a></span>GetNetworkEntangledQubitsIds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetNetworkEntangledQubitsIds </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the qubit ids used for entanglement between hosts for the specified host. </p>
<p>Get the qubit ids used for entanglement between hosts for the specified host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostId</td><td>The id of the host to get the qubit ids for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with the qubit ids. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#af1ed31e3fd4c550c08ee15df2bc8e2d2">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01387">1387</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a339d55ef40533b3cbcf377629e83f160" name="a339d55ef40533b3cbcf377629e83f160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339d55ef40533b3cbcf377629e83f160">&#9670;&#160;</a></span>GetNumberOfGatesDistributedOrCut()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetNumberOfGatesDistributedOrCut </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of gates that span more than one host. </p>
<p>Get the number of gates that span more than one host for the given circuit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuit</td><td>The circuit to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of gates that need distribution or cutting. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00712">712</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a9dd489fb138feee985beb73a87f4059a" name="a9dd489fb138feee985beb73a87f4059a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd489fb138feee985beb73a87f4059a">&#9670;&#160;</a></span>GetNumClassicalBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetNumClassicalBits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of classical bits in the network. </p>
<p>Get the number of classical bits in the network, excluding the classical bits used for measurement of entanglement qubits between the hosts.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of classical bits in the network. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#aae2e82505c0d886286a69e5912d49ff8">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00988">988</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a702fc9d436751911472e0cbde2eec518" name="a702fc9d436751911472e0cbde2eec518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702fc9d436751911472e0cbde2eec518">&#9670;&#160;</a></span>GetNumClassicalBitsForHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetNumClassicalBitsForHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of classical bits in the network for the specified host. </p>
<p>Get the number of classical bits in the network for the specified host, excluding the classical bits used for measurement of entanglement qubits between the hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostId</td><td>The id of the host to get the number of classical bits for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of classical bits in the network for the specified host. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a06d737a893006c0cab0668921aea6f98">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01007">1007</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a46f9387675110a28a81c10794f3f1c45" name="a46f9387675110a28a81c10794f3f1c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f9387675110a28a81c10794f3f1c45">&#9670;&#160;</a></span>GetNumHosts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetNumHosts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of hosts in the network. </p>
<p>Get the number of hosts in the network, excluding the controller.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of hosts in the network. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a625f23dc01a47dd53cfca1846ae43d7a">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00913">913</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a1b978a5df60184fcf694e53d495b738d" name="a1b978a5df60184fcf694e53d495b738d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b978a5df60184fcf694e53d495b738d">&#9670;&#160;</a></span>GetNumNetworkEntangledQubits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetNumNetworkEntangledQubits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of qubits used for entanglement between hosts. </p>
<p>Get the number of qubits used for entanglement between hosts in the network. For the simple network it's one qubit per host.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of qubits used for entanglement between hosts. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#ab19aa63f1ee949ef027655383ba50aaf">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00954">954</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a8dc46b6119038c7ee8b62c6db36ffb56" name="a8dc46b6119038c7ee8b62c6db36ffb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc46b6119038c7ee8b62c6db36ffb56">&#9670;&#160;</a></span>GetNumNetworkEntangledQubitsForHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetNumNetworkEntangledQubitsForHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of qubits used for entanglement between hosts for the specified host. </p>
<p>Get the number of qubits used for entanglement between hosts in the network for the specified host. For the simple network it's a single qubit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostId</td><td>The id of the host to get the number of qubits used for entanglement between hosts for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of qubits used for entanglement between hosts for the specified host. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a28ae2af8f51bb864ff5cde89c3df9bef">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00974">974</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a31c2704fa3dc82eaf63005774231deca" name="a31c2704fa3dc82eaf63005774231deca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c2704fa3dc82eaf63005774231deca">&#9670;&#160;</a></span>GetNumQubits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetNumQubits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of qubits in the network. </p>
<p>Get the number of qubits in the network, excluding the qubits used for entanglement between the hosts.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of qubits in the network. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a91ff17ec7e74a480cb9bd84692185377">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00923">923</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a22737771248b0de2aaa230360db6cdf0" name="a22737771248b0de2aaa230360db6cdf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22737771248b0de2aaa230360db6cdf0">&#9670;&#160;</a></span>GetNumQubitsForHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetNumQubitsForHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of qubits in the network for the specified host. </p>
<p>Get the number of qubits in the network for the specified host, excluding the qubits used for entanglement between the hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostId</td><td>The id of the host to get the number of qubits for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of qubits in the network for the specified host. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a9a3d9fa2fb43484c48dc0494ca3a7bc0">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00940">940</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a329778029550a5ead52e77e1966ecb40" name="a329778029550a5ead52e77e1966ecb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329778029550a5ead52e77e1966ecb40">&#9670;&#160;</a></span>GetOptimizeSimulator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetOptimizeSimulator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the 'optimize' flag. </p>
<p>Returns the flag set by <a class="el" href="#a6f51d41faf736e0e8cb9ebe236ff6b88" title="Allows using an optimized simulator.">SetOptimizeSimulator()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The 'optimize' flag. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#ac1fb6303ce4490514280816730b52562">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01610">1610</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a2fe97c1659f672739a53021d4a9ec7a8" name="a2fe97c1659f672739a53021d4a9ec7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe97c1659f672739a53021d4a9ec7a8">&#9670;&#160;</a></span>GetQubitsIds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetQubitsIds </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the qubit ids for the specified host. </p>
<p>Get the qubit ids for the specified host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostId</td><td>The id of the host to get the qubit ids for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with the qubit ids. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a4684d4fb1f0f53a48bdf9cb673a51845">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01371">1371</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a9d2c5711de54c064387946b8381ce250" name="a9d2c5711de54c064387946b8381ce250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2c5711de54c064387946b8381ce250">&#9670;&#160;</a></span>GetScheduler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classSchedulers_1_1IScheduler.html">Schedulers::IScheduler</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetScheduler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scheduler for the network. </p>
<p>Get the scheduler for the network.</p>
<dl class="section return"><dt>Returns</dt><dd>The scheduler for the network. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSchedulers_1_1IScheduler.html" title="The scheduler interface.">Schedulers::IScheduler</a> </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a665a3289757c1436f6401ee9f8690312">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00873">873</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="abdba56e38cd3e43847e664791510d980" name="abdba56e38cd3e43847e664791510d980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdba56e38cd3e43847e664791510d980">&#9670;&#160;</a></span>GetSimulator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classSimulators_1_1ISimulator.html">Simulators::ISimulator</a> &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetSimulator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the simulator for the network. </p>
<p>Get the simulator for the network.</p>
<dl class="section return"><dt>Returns</dt><dd>The simulator for the network. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimulators_1_1ISimulator.html" title="Interface class for a quantum computing simulator.">Simulators::ISimulator</a> </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a675261875b618da2206a587b487656f3">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00832">832</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="ab8a12099dd76cd1c7c63b960405d95a3" name="ab8a12099dd76cd1c7c63b960405d95a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a12099dd76cd1c7c63b960405d95a3">&#9670;&#160;</a></span>GetSimulatorsSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNetwork_1_1INetwork.html#aa948773ddeeadbf03487095c5ac1da11">BaseClass::SimulatorsSet</a> &amp; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetSimulatorsSet </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the optimizations simulators set. </p>
<p>Get the optimization simulators set. To be used internally, will not be exposed from the library.</p>
<dl class="section return"><dt>Returns</dt><dd>The simulators set. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#aa36fc37a82fef4eb146f8e931c3d28f5">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01620">1620</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a231f579e098ac6597b4c92963ec15f21" name="a231f579e098ac6597b4c92963ec15f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231f579e098ac6597b4c92963ec15f21">&#9670;&#160;</a></span>GetState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCircuits_1_1OperationState.html">Circuits::OperationState</a> &amp; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetState </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the classical state of the network. </p>
<p>Gets a reference to the classical state of the network.</p>
<dl class="section return"><dt>Returns</dt><dd>The classical state of the network. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Circuits::ClassicalState </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a463a521e8619f91e0130c161e860f5bb">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00844">844</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="af5f9354c22833d18b224930617ee8fe9" name="af5f9354c22833d18b224930617ee8fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f9354c22833d18b224930617ee8fe9">&#9670;&#160;</a></span>GetType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceNetwork.html#a33e9851296c0fe8a699eab9c27ec656e">NetworkType</a> <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::GetType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of the network. </p>
<p>Get the type of the network. </p><dl class="section return"><dt>Returns</dt><dd>The type of the network. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceNetwork.html#a33e9851296c0fe8a699eab9c27ec656e" title="The type of the network.">NetworkType</a> </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#af4c955f8422f6728514456a8186e8150">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01060">1060</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="aaf5164566e8f69bce7742c24b0432add" name="aaf5164566e8f69bce7742c24b0432add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5164566e8f69bce7742c24b0432add">&#9670;&#160;</a></span>IsDistributedOperation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::IsDistributedOperation </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the circuit operation is distributed. </p>
<p>Check if the specified circuit operation is distributed. A distributed operation is an operation that is executed on multiple hosts. This does not include the operations that also operate on the entanglement qubits between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified circuit operation is distributed, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01100">1100</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="ae929327ee3fe961a4838a6df9bc904bd" name="ae929327ee3fe961a4838a6df9bc904bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae929327ee3fe961a4838a6df9bc904bd">&#9670;&#160;</a></span>IsEntanglementQubitBusy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::IsEntanglementQubitBusy </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the specified qubit used for entanglement between hosts is busy. </p>
<p>Check if the specified qubit used for entanglement between hosts is busy. It's not used in the simple network, because it doesn't allow quantum communication between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubitId</td><td>The id of the qubit to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified qubit used for entanglement between hosts is busy, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#aa25d8393ad2adda6ce7c5693fb8aaa53">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01453">1453</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a7698358b31b3e41bc18eff58979b662e" name="a7698358b31b3e41bc18eff58979b662e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7698358b31b3e41bc18eff58979b662e">&#9670;&#160;</a></span>IsEntanglingGate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::IsEntanglingGate </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a gate is an entangling gate. </p>
<p>An entangling gate is a gate that operates on two qubits that are used for entanglement between hosts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified circuit operation is an entangling gate, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01155">1155</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a374adb2fb01093a5b558011c229688dc" name="a374adb2fb01093a5b558011c229688dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374adb2fb01093a5b558011c229688dc">&#9670;&#160;</a></span>IsLocalOperation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::IsLocalOperation </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the circuit operation is local. </p>
<p>Check if the specified circuit operation is local. A local operation is an operation that is executed on a single host. This does not include the operations that also operate on the entanglement qubits between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified circuit operation is local, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01074">1074</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a514869063d4a922289c553126ecd9513" name="a514869063d4a922289c553126ecd9513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514869063d4a922289c553126ecd9513">&#9670;&#160;</a></span>IsNetworkEntangledQubit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::IsNetworkEntangledQubit </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the specified qubit id is for a qubit used for entanglement between hosts. </p>
<p>Check if the specified qubit id is for a qubit used for entanglement between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubitId</td><td>The id of the qubit to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified qubit id is for a qubit used for entanglement between hosts, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a146fb9a9fa27fad9e7ad44026618b3a3">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01437">1437</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a211b84ee9b5cc93d6aa4a72e06533dc1" name="a211b84ee9b5cc93d6aa4a72e06533dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211b84ee9b5cc93d6aa4a72e06533dc1">&#9670;&#160;</a></span>MapCircuitOnHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; <a class="el" href="namespaceTypes.html#afda27b666a29ff2e858b10ee1a7e4b73">Types::qubit_t</a>, <a class="el" href="namespaceTypes.html#afda27b666a29ff2e858b10ee1a7e4b73">Types::qubit_t</a> &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::MapCircuitOnHost </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>nrQubits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>nrCbits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>useSeparateSimForHosts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map the circuit on the host. </p>
<p>Map the circuit on the host. It's used only if there is an execution on a single host and the passed circuit had a different mapping for qubits than the host qubits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuit</td><td>The circuit to map. </td></tr>
    <tr><td class="paramname">hostId</td><td>The id of the host to map the circuit on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reverse qubits/cbits map. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01976">1976</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a15e13bf36e6bc35af21916c6c6b5304a" name="a15e13bf36e6bc35af21916c6c6b5304a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e13bf36e6bc35af21916c6c6b5304a">&#9670;&#160;</a></span>MarkEntangledQubitFree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::MarkEntangledQubitFree </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the specified qubit used for entanglement between hosts as free. </p>
<p>Mark the specified qubit used for entanglement between hosts as free. This is used to mark the qubits as free when they are not used anymore for an entanglement between hosts. It's not used in the simple network, because it doesn't allow quantum communication between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubitId</td><td>The id of the qubit to mark as free. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#aa50510ad514671f454c87392f69bb038">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01503">1503</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="ac4476e8cad5690ab82646d426dabbb02" name="ac4476e8cad5690ab82646d426dabbb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4476e8cad5690ab82646d426dabbb02">&#9670;&#160;</a></span>MarkEntangledQubitsBusy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::MarkEntangledQubitsBusy </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the pair of the specified qubits used for entanglement between hosts as busy. </p>
<p>Mark the pair of the specified qubits used for entanglement between hosts as busy. This is used to mark the qubits as busy when they are used for creating an entanglement between hosts. It's not used in the simple network, because it doesn't allow quantum communication between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubitId1</td><td>The id of the first qubit to mark as busy. </td></tr>
    <tr><td class="paramname">qubitId2</td><td>The id of the second qubit to mark as busy. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#aca3f0b815a508a20ec442de9bdcd6d2b">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01487">1487</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="abe1ecd77255433123c9a47e3e2a67691" name="abe1ecd77255433123c9a47e3e2a67691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1ecd77255433123c9a47e3e2a67691">&#9670;&#160;</a></span>OperatesWithNetworkEntangledQubit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::OperatesWithNetworkEntangledQubit </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the circuit operation operates on the entanglement qubits between hosts. </p>
<p>Check if the specified circuit operation operates on the entanglement qubits between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified circuit operation operates on the entanglement qubits between hosts, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01134">1134</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a1943e1e449c97dccd8af0d8791071399" name="a1943e1e449c97dccd8af0d8791071399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1943e1e449c97dccd8af0d8791071399">&#9670;&#160;</a></span>OptimizationSimulatorExists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::OptimizationSimulatorExists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a></td>          <td class="paramname"><span class="paramname"><em>kind</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a simulator exists in the optimization set. </p>
<p>Checks if a simulator exists in the optimization set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the simulator to check. </td></tr>
    <tr><td class="paramname">kind</td><td>The kind of the simulation to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the simulator exists in the optimization set, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a6f83d88bee54c79b77c0e5b2e562c26d">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01678">1678</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="aed8f20ae183d2357bdfda05ec88d2450" name="aed8f20ae183d2357bdfda05ec88d2450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8f20ae183d2357bdfda05ec88d2450">&#9670;&#160;</a></span>RemoveAllOptimizationSimulatorsAndAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::RemoveAllOptimizationSimulatorsAndAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a></td>          <td class="paramname"><span class="paramname"><em>kind</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all simulators from the simulators optimization set and adds the one specified. </p>
<p>Removes all simulators from the simulators optimization set and adds the one specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the simulator to add. </td></tr>
    <tr><td class="paramname">kind</td><td>The kind of the simulation to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#ae731339397d14238715fa4ca68263de0">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01661">1661</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a5823dfcf86f0df4872a16d7b9eb89d65" name="a5823dfcf86f0df4872a16d7b9eb89d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5823dfcf86f0df4872a16d7b9eb89d65">&#9670;&#160;</a></span>RemoveOptimizationSimulator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::RemoveOptimizationSimulator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a></td>          <td class="paramname"><span class="paramname"><em>kind</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a simulator from the simulators optimization set. </p>
<p>Removes a simulator from the simulators optimization set, if it exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the simulator to remove. </td></tr>
    <tr><td class="paramname">kind</td><td>The kind of the simulation to remove. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a19058e2cd51add8be754aa68501e138b">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01646">1646</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a2d5710c5da315173effc677c3ddaa113" name="a2d5710c5da315173effc677c3ddaa113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5710c5da315173effc677c3ddaa113">&#9670;&#160;</a></span>RepeatedExecute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1537dfd62f404ccfbfd5cebf9e87b5ae">ExecuteResults</a> <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::RepeatedExecute </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>shots</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the circuit on the network, repeatedly. </p>
<p>Execute the circuit on the network, distributing the operations to the hosts, repeating the execution 'shots' times. The way the circuit is distributed to the hosts depends on the specific interface implementations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuit</td><td>The circuit to execute. </td></tr>
    <tr><td class="paramname">shots</td><td>The number of times to repeat the execution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map with the results of the execution, where the key is the qubit id and the value is the number of times the qubit was measured to be 1. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00361">361</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a28c0df1f01d0e55828a1bfb65277589c" name="a28c0df1f01d0e55828a1bfb65277589c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c0df1f01d0e55828a1bfb65277589c">&#9670;&#160;</a></span>RepeatedExecuteOnHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1537dfd62f404ccfbfd5cebf9e87b5ae">ExecuteResults</a> <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::RepeatedExecuteOnHost </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>shots</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the circuit on the specified host, repeatedly. </p>
<p>Execute the circuit on the specified host, repeating the execution 'shots' times. The circuit must fit on the host, otherwise an exception is thrown. The circuit will be mapped on the specified host, if its qubits start with indexing from 0 (if already mapped, the qubits won't be altered).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuit</td><td>The circuit to execute. </td></tr>
    <tr><td class="paramname">hostId</td><td>The id of the host to execute the circuit on. </td></tr>
    <tr><td class="paramname">shots</td><td>The number of times to repeat the execution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map with the results of the execution, where the key is the qubit id and the value is the number of times the qubit was measured to be 1. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l00550">550</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="ab79d8495b514562b0358ce37d63ceb2b" name="ab79d8495b514562b0358ce37d63ceb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79d8495b514562b0358ce37d63ceb2b">&#9670;&#160;</a></span>SendPacket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::SendPacket </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>fromHostId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>toHostId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>packet</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a packet between two hosts. </p>
<p>Sends a packet between the two specified hosts. It's not used in the simple network, because sending/receiving the classical information is done using a shared classical state for the simulator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromHostId</td><td>The id of the host to send the packet from. </td></tr>
    <tr><td class="paramname">toHostId</td><td>The id of the host to send the packet to. </td></tr>
    <tr><td class="paramname">packet</td><td>The packet to send. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a4c65af505d69a5eb14744ea55dd633c3">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01048">1048</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a026f0fe48a279022b64bd962c6bef0ea" name="a026f0fe48a279022b64bd962c6bef0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026f0fe48a279022b64bd962c6bef0ea">&#9670;&#160;</a></span>SetController()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::SetController </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1IController.html">IController</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cntrl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the network controller host. </p>
<p>Sets the network controller host. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cntrl</td><td>The controller host. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNetwork_1_1IController.html" title="The controller host interface.">IController</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01031">1031</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a666367ed32af514cc8a653bc06bc293a" name="a666367ed32af514cc8a653bc06bc293a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666367ed32af514cc8a653bc06bc293a">&#9670;&#160;</a></span>SetMaxSimulators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::SetMaxSimulators </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of simulators that can be used in the network. </p>
<p>Set the maximum number of simulators that can be used in the network. This is used to limit the number of simulators (and corresponding threads) that can be used in the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="#ada9b6cba5dab37d06d39e86f0863b7ce" title="The maximum number of simulators that can be used in the network.">maxSimulators</a></td><td>The maximum number of simulators that can be used in the network. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#a27a20e63e59a20e27cb42f2bdd1184fa">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01581">1581</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a6f51d41faf736e0e8cb9ebe236ff6b88" name="a6f51d41faf736e0e8cb9ebe236ff6b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f51d41faf736e0e8cb9ebe236ff6b88">&#9670;&#160;</a></span>SetOptimizeSimulator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::SetOptimizeSimulator </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>optimize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows using an optimized simulator. </p>
<p>If set, allows changing the simulator with an optimized one. States/amplitudes are not available in such a case, disable if you need them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optimize</td><td>If true, the simulator will be optimized if possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classNetwork_1_1INetwork.html#ae0e5c5761d2d2443369978d9416d51d8">Network::INetwork&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l01599">1599</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a905d6430ef17c214477c64e6c4f219a0" name="a905d6430ef17c214477c64e6c4f219a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905d6430ef17c214477c64e6c4f219a0">&#9670;&#160;</a></span>classicalState</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCircuits_1_1OperationState.html">Circuits::OperationState</a> <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::classicalState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The classical state of the network. </p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l02074">2074</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="adb92ba31d3aff643374bd30da93805c9" name="adb92ba31d3aff643374bd30da93805c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb92ba31d3aff643374bd30da93805c9">&#9670;&#160;</a></span>controller</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classNetwork_1_1IController.html">IController</a>&lt;Time&gt; &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::controller</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The controller for the network. </p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l02082">2082</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a9a2125d19b5cf1b55e373e661e32f0aa" name="a9a2125d19b5cf1b55e373e661e32f0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2125d19b5cf1b55e373e661e32f0aa">&#9670;&#160;</a></span>distCirc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt;Time&gt; &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::distCirc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The distributed circuit. </p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l02079">2079</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a7bb91682710357f62cbba79c36c07ed4" name="a7bb91682710357f62cbba79c36c07ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb91682710357f62cbba79c36c07ed4">&#9670;&#160;</a></span>hosts</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classNetwork_1_1IHost.html">IHost</a>&lt;Time&gt; &gt; &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::hosts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The hosts in the network. </p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l02087">2087</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a2c15255689087b24bfebe41e385b273c" name="a2c15255689087b24bfebe41e385b273c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c15255689087b24bfebe41e385b273c">&#9670;&#160;</a></span>lastMethod</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a> <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::lastMethod</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">                                  =</div>
<div class="line"><a class="code hl_enumvalue" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789a445db308b141bb2618448cf7c4212359">Simulators::SimulationType::kStatevector</a></div>
<div class="ttc" id="anamespaceSimulators_html_a36be947268c6955a4a9f323ee6e7c789a445db308b141bb2618448cf7c4212359"><div class="ttname"><a href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789a445db308b141bb2618448cf7c4212359">Simulators::SimulationType::kStatevector</a></div><div class="ttdeci">@ kStatevector</div><div class="ttdoc">statevector simulation type</div><div class="ttdef"><b>Definition</b> <a href="State_8h_source.html#l00083">State.h:83</a></div></div>
</div><!-- fragment -->
<p>The last simulation method used. </p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l02061">2061</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a03602197482a8ab5f3af8efd44d07e20" name="a03602197482a8ab5f3af8efd44d07e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03602197482a8ab5f3af8efd44d07e20">&#9670;&#160;</a></span>lastSimulatorType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a> <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::lastSimulatorType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">                                        =</div>
<div class="line"><a class="code hl_enumvalue" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aaa20dd7a84a53e5ace6f43951e3f0b0337">Simulators::SimulatorType::kQCSim</a></div>
<div class="ttc" id="anamespaceSimulators_html_a68fec15db9b51accdfe4c6d69f2536aaa20dd7a84a53e5ace6f43951e3f0b0337"><div class="ttname"><a href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aaa20dd7a84a53e5ace6f43951e3f0b0337">Simulators::SimulatorType::kQCSim</a></div><div class="ttdeci">@ kQCSim</div><div class="ttdoc">qcsim simulator type</div><div class="ttdef"><b>Definition</b> <a href="State_8h_source.html#l00067">State.h:67</a></div></div>
</div><!-- fragment -->
<p>The last simulator type used. </p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l02059">2059</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a02320f596d00f3b51716656a1900d080" name="a02320f596d00f3b51716656a1900d080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02320f596d00f3b51716656a1900d080">&#9670;&#160;</a></span>maxBondDim</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::maxBondDim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l02065">2065</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="ada9b6cba5dab37d06d39e86f0863b7ce" name="ada9b6cba5dab37d06d39e86f0863b7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9b6cba5dab37d06d39e86f0863b7ce">&#9670;&#160;</a></span>maxSimulators</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::maxSimulators</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">                 = QC::QubitRegisterCalculator&lt;&gt;::</div>
<div class="line">GetNumberOfThreads()</div>
</div><!-- fragment -->
<p>The maximum number of simulators that can be used in the network. </p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l02069">2069</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="ab096a7d8b912200b36f81e4c3571aa1c" name="ab096a7d8b912200b36f81e4c3571aa1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab096a7d8b912200b36f81e4c3571aa1c">&#9670;&#160;</a></span>mpsSample</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::mpsSample</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l02067">2067</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a2da42e0d0e4f7269e549cc9bcdbd489b" name="a2da42e0d0e4f7269e549cc9bcdbd489b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da42e0d0e4f7269e549cc9bcdbd489b">&#9670;&#160;</a></span>optimizeSimulator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::optimizeSimulator = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The flag to optimize the simulator. </p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l02056">2056</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a06785803127fbf6c85d43dbc61d2f603" name="a06785803127fbf6c85d43dbc61d2f603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06785803127fbf6c85d43dbc61d2f603">&#9670;&#160;</a></span>simulator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classSimulators_1_1ISimulator.html">Simulators::ISimulator</a>&gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::simulator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The quantum computing simulator for the network. </p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l02076">2076</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a40a5c222e5241b6dcbee325c48ec8acb" name="a40a5c222e5241b6dcbee325c48ec8acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a5c222e5241b6dcbee325c48ec8acb">&#9670;&#160;</a></span>simulatorsEstimator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classEstimators_1_1SimulatorsEstimatorInterface.html">Estimators::SimulatorsEstimatorInterface</a>&lt;Time&gt; &gt; <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::simulatorsEstimator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The simulators estimator. </p>

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l02090">2090</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a7c1824a218d3ec95663bb8642f5f894c" name="a7c1824a218d3ec95663bb8642f5f894c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1824a218d3ec95663bb8642f5f894c">&#9670;&#160;</a></span>simulatorsForOptimizations</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNetwork_1_1INetwork.html#aa948773ddeeadbf03487095c5ac1da11">BaseClass::SimulatorsSet</a> <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::simulatorsForOptimizations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l02057">2057</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<a id="a0a4873717a9c027efeb5be2f680652f8" name="a0a4873717a9c027efeb5be2f680652f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4873717a9c027efeb5be2f680652f8">&#9670;&#160;</a></span>singularValueThreshold</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type, class Controller = SimpleController&lt;Time&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html">Network::SimpleDisconnectedNetwork</a>&lt; Time, Controller &gt;::singularValueThreshold</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SimpleDisconnectedNetwork_8h_source.html#l02066">2066</a> of file <a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SimpleDisconnectedNetwork_8h_source.html">SimpleDisconnectedNetwork.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceNetwork.html">Network</a></li><li class="navelem"><a href="classNetwork_1_1SimpleDisconnectedNetwork.html">SimpleDisconnectedNetwork</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for Maestro by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.1 </li>
  </ul>
</div>
</body>
</html>
