<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Maestro: Network::INetwork&lt; Time &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Maestro<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Unified interface for quantum circuit simulation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classNetwork_1_1INetwork.html','','classNetwork_1_1INetwork-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Network::INetwork&lt; Time &gt; Class Template Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The network interface.
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Network_8h_source.html">Network.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Network::INetwork&lt; Time &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classNetwork_1_1INetwork.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa7e4e730dac51e0ae031528ecdfe7378" id="r_aa7e4e730dac51e0ae031528ecdfe7378"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7e4e730dac51e0ae031528ecdfe7378">ExecuteResults</a> = typename <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt;Time&gt;::ExecuteResults</td></tr>
<tr class="memitem:ae6c065febe1ab7eb1701e79d89475096" id="r_ae6c065febe1ab7eb1701e79d89475096"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6c065febe1ab7eb1701e79d89475096">SimulatorPair</a></td></tr>
<tr class="memitem:a9b12b44710338adee5d0368b6dd63047" id="r_a9b12b44710338adee5d0368b6dd63047"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b12b44710338adee5d0368b6dd63047">SimulatorsSet</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5ab3268ca8816f31d22c65a7bcdba609" id="r_a5ab3268ca8816f31d22c65a7bcdba609"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ab3268ca8816f31d22c65a7bcdba609">~INetwork</a> ()=default</td></tr>
<tr class="memdesc:a5ab3268ca8816f31d22c65a7bcdba609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="classNetwork_1_1INetwork.html" title="The network interface.">INetwork</a> object.  <br /></td></tr>
<tr class="memitem:a4a09ddecdeb48ce7e5ef09a67ab813d8" id="r_a4a09ddecdeb48ce7e5ef09a67ab813d8"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a09ddecdeb48ce7e5ef09a67ab813d8">GetNumberOfGatesDistributedOrCut</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit) const =0</td></tr>
<tr class="memdesc:a4a09ddecdeb48ce7e5ef09a67ab813d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of gates that span more than one host.  <br /></td></tr>
<tr class="memitem:a08b1adb6d8cb973553490cdba72ee264" id="r_a08b1adb6d8cb973553490cdba72ee264"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08b1adb6d8cb973553490cdba72ee264">Execute</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit)=0</td></tr>
<tr class="memdesc:a08b1adb6d8cb973553490cdba72ee264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the network.  <br /></td></tr>
<tr class="memitem:ac7b5e621b3f084e00a681c914176bc56" id="r_ac7b5e621b3f084e00a681c914176bc56"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7b5e621b3f084e00a681c914176bc56">ExecuteOnHost</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit, size_t hostId)=0</td></tr>
<tr class="memdesc:ac7b5e621b3f084e00a681c914176bc56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the specified host.  <br /></td></tr>
<tr class="memitem:a373c422b6f4a2895bfe95daba2744c35" id="r_a373c422b6f4a2895bfe95daba2744c35"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a373c422b6f4a2895bfe95daba2744c35">ExecuteExpectations</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit, const std::vector&lt; std::string &gt; &amp;paulis)=0</td></tr>
<tr class="memdesc:a373c422b6f4a2895bfe95daba2744c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the network and return the expectation values for the specified Pauli strings.  <br /></td></tr>
<tr class="memitem:a66764ee7024642ef150d7765abf084a2" id="r_a66764ee7024642ef150d7765abf084a2"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66764ee7024642ef150d7765abf084a2">ExecuteOnHostExpectations</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit, size_t hostId, const std::vector&lt; std::string &gt; &amp;paulis)=0</td></tr>
<tr class="memdesc:a66764ee7024642ef150d7765abf084a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the specified host and return the expectation values for the specified Pauli strings.  <br /></td></tr>
<tr class="memitem:a19cbf8ca93efdc7d9e2c1bae521e5065" id="r_a19cbf8ca93efdc7d9e2c1bae521e5065"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#aa7e4e730dac51e0ae031528ecdfe7378">ExecuteResults</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19cbf8ca93efdc7d9e2c1bae521e5065">RepeatedExecute</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit, size_t shots=1000)=0</td></tr>
<tr class="memdesc:a19cbf8ca93efdc7d9e2c1bae521e5065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the network, repeatedly.  <br /></td></tr>
<tr class="memitem:a494d28f1e405949d50dbfda9feee3950" id="r_a494d28f1e405949d50dbfda9feee3950"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aa7e4e730dac51e0ae031528ecdfe7378">ExecuteResults</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a494d28f1e405949d50dbfda9feee3950">RepeatedExecuteCircuit</a> (const <a class="el" href="structSchedulers_1_1ExecuteCircuit.html">Schedulers::ExecuteCircuit</a>&lt; Time &gt; &amp;executeCircuit)</td></tr>
<tr class="memdesc:a494d28f1e405949d50dbfda9feee3950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the network, repeatedly.  <br /></td></tr>
<tr class="memitem:a4c390106c9a7fbd4860052fc38b96665" id="r_a4c390106c9a7fbd4860052fc38b96665"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#aa7e4e730dac51e0ae031528ecdfe7378">ExecuteResults</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c390106c9a7fbd4860052fc38b96665">RepeatedExecuteOnHost</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit, size_t hostId, size_t shots=1000)=0</td></tr>
<tr class="memdesc:a4c390106c9a7fbd4860052fc38b96665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the specified host, repeatedly.  <br /></td></tr>
<tr class="memitem:a2642458270fe90107586695b550fac51" id="r_a2642458270fe90107586695b550fac51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aa7e4e730dac51e0ae031528ecdfe7378">ExecuteResults</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2642458270fe90107586695b550fac51">RepeatedExecuteCircuitOnHost</a> (const <a class="el" href="structSchedulers_1_1ExecuteCircuit.html">Schedulers::ExecuteCircuit</a>&lt; Time &gt; &amp;executeCircuit, size_t hostId)</td></tr>
<tr class="memdesc:a2642458270fe90107586695b550fac51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the circuit on the specified host, repeatedly.  <br /></td></tr>
<tr class="memitem:a5e8996656e5c376f82c9b5371931341c" id="r_a5e8996656e5c376f82c9b5371931341c"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="#aa7e4e730dac51e0ae031528ecdfe7378">ExecuteResults</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e8996656e5c376f82c9b5371931341c">ExecuteScheduled</a> (const std::vector&lt; <a class="el" href="structSchedulers_1_1ExecuteCircuit.html">Schedulers::ExecuteCircuit</a>&lt; Time &gt; &gt; &amp;circuits)=0</td></tr>
<tr class="memdesc:a5e8996656e5c376f82c9b5371931341c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule and execute circuits on the network.  <br /></td></tr>
<tr class="memitem:a8e6daa8026a734401c90514b76f12044" id="r_a8e6daa8026a734401c90514b76f12044"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e6daa8026a734401c90514b76f12044">CreateSimulator</a> (<a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a> simType=<a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aaa20dd7a84a53e5ace6f43951e3f0b0337">Simulators::SimulatorType::kQCSim</a>, <a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a> simExecType=<a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789a62f6eb80f4ebe16a28e8405dffac7fea">Simulators::SimulationType::kMatrixProductState</a>, size_t nrQubits=0)=0</td></tr>
<tr class="memdesc:a8e6daa8026a734401c90514b76f12044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the simulator for the network.  <br /></td></tr>
<tr class="memitem:a675261875b618da2206a587b487656f3" id="r_a675261875b618da2206a587b487656f3"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classSimulators_1_1ISimulator.html">Simulators::ISimulator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a675261875b618da2206a587b487656f3">GetSimulator</a> () const =0</td></tr>
<tr class="memdesc:a675261875b618da2206a587b487656f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the simulator for the network.  <br /></td></tr>
<tr class="memitem:a79ac17adf81c745de120e19b78a1743c" id="r_a79ac17adf81c745de120e19b78a1743c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79ac17adf81c745de120e19b78a1743c">Configure</a> (const char *key, const char *value)=0</td></tr>
<tr class="memdesc:a79ac17adf81c745de120e19b78a1743c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the network.  <br /></td></tr>
<tr class="memitem:aad379273cb76f8c2e734fcad6010950e" id="r_aad379273cb76f8c2e734fcad6010950e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad379273cb76f8c2e734fcad6010950e">CreateScheduler</a> (<a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1">SchedulerType</a> schType=<a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1ab90c9b48118b61527e8d21a4bb699c4b">SchedulerType::kNoEntanglementQubitsParallel</a>)=0</td></tr>
<tr class="memdesc:aad379273cb76f8c2e734fcad6010950e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the scheduler for the network.  <br /></td></tr>
<tr class="memitem:a665a3289757c1436f6401ee9f8690312" id="r_a665a3289757c1436f6401ee9f8690312"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classSchedulers_1_1IScheduler.html">Schedulers::IScheduler</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a665a3289757c1436f6401ee9f8690312">GetScheduler</a> () const =0</td></tr>
<tr class="memdesc:a665a3289757c1436f6401ee9f8690312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scheduler for the network.  <br /></td></tr>
<tr class="memitem:a87e1848fa60b03837f25819af4b7a421" id="r_a87e1848fa60b03837f25819af4b7a421"><td class="memItemLeft" align="right" valign="top">virtual const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1IHost.html">IHost</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87e1848fa60b03837f25819af4b7a421">GetHost</a> (size_t hostId) const =0</td></tr>
<tr class="memdesc:a87e1848fa60b03837f25819af4b7a421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the host with the specified id.  <br /></td></tr>
<tr class="memitem:af7014ccd32005ed57052893c1973c877" id="r_af7014ccd32005ed57052893c1973c877"><td class="memItemLeft" align="right" valign="top">virtual const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1IController.html">IController</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7014ccd32005ed57052893c1973c877">GetController</a> () const =0</td></tr>
<tr class="memdesc:af7014ccd32005ed57052893c1973c877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the controller for the network.  <br /></td></tr>
<tr class="memitem:a463a521e8619f91e0130c161e860f5bb" id="r_a463a521e8619f91e0130c161e860f5bb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCircuits_1_1OperationState.html">Circuits::OperationState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a463a521e8619f91e0130c161e860f5bb">GetState</a> ()=0</td></tr>
<tr class="memdesc:a463a521e8619f91e0130c161e860f5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the classical state of the network.  <br /></td></tr>
<tr class="memitem:a625f23dc01a47dd53cfca1846ae43d7a" id="r_a625f23dc01a47dd53cfca1846ae43d7a"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a625f23dc01a47dd53cfca1846ae43d7a">GetNumHosts</a> () const =0</td></tr>
<tr class="memdesc:a625f23dc01a47dd53cfca1846ae43d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of hosts in the network.  <br /></td></tr>
<tr class="memitem:a91ff17ec7e74a480cb9bd84692185377" id="r_a91ff17ec7e74a480cb9bd84692185377"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91ff17ec7e74a480cb9bd84692185377">GetNumQubits</a> () const =0</td></tr>
<tr class="memdesc:a91ff17ec7e74a480cb9bd84692185377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of qubits in the network.  <br /></td></tr>
<tr class="memitem:a9a3d9fa2fb43484c48dc0494ca3a7bc0" id="r_a9a3d9fa2fb43484c48dc0494ca3a7bc0"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a3d9fa2fb43484c48dc0494ca3a7bc0">GetNumQubitsForHost</a> (size_t hostId) const =0</td></tr>
<tr class="memdesc:a9a3d9fa2fb43484c48dc0494ca3a7bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of qubits in the network for the specified host.  <br /></td></tr>
<tr class="memitem:ab19aa63f1ee949ef027655383ba50aaf" id="r_ab19aa63f1ee949ef027655383ba50aaf"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab19aa63f1ee949ef027655383ba50aaf">GetNumNetworkEntangledQubits</a> () const =0</td></tr>
<tr class="memdesc:ab19aa63f1ee949ef027655383ba50aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of qubits used for entanglement between hosts.  <br /></td></tr>
<tr class="memitem:a28ae2af8f51bb864ff5cde89c3df9bef" id="r_a28ae2af8f51bb864ff5cde89c3df9bef"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28ae2af8f51bb864ff5cde89c3df9bef">GetNumNetworkEntangledQubitsForHost</a> (size_t hostId) const =0</td></tr>
<tr class="memdesc:a28ae2af8f51bb864ff5cde89c3df9bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of qubits used for entanglement between hosts for the specified host.  <br /></td></tr>
<tr class="memitem:aae2e82505c0d886286a69e5912d49ff8" id="r_aae2e82505c0d886286a69e5912d49ff8"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae2e82505c0d886286a69e5912d49ff8">GetNumClassicalBits</a> () const =0</td></tr>
<tr class="memdesc:aae2e82505c0d886286a69e5912d49ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of classical bits in the network.  <br /></td></tr>
<tr class="memitem:a06d737a893006c0cab0668921aea6f98" id="r_a06d737a893006c0cab0668921aea6f98"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06d737a893006c0cab0668921aea6f98">GetNumClassicalBitsForHost</a> (size_t hostId) const =0</td></tr>
<tr class="memdesc:a06d737a893006c0cab0668921aea6f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of classical bits in the network for the specified host.  <br /></td></tr>
<tr class="memitem:a59bb55fcc09c35d5aa1c21f5ad2249d1" id="r_a59bb55fcc09c35d5aa1c21f5ad2249d1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59bb55fcc09c35d5aa1c21f5ad2249d1">AreQubitsOnSameHost</a> (size_t qubitId1, size_t qubitId2) const =0</td></tr>
<tr class="memdesc:a59bb55fcc09c35d5aa1c21f5ad2249d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified qubits are on the same host.  <br /></td></tr>
<tr class="memitem:ad8bf9a776bba8f30a97f49f80d58eb6d" id="r_ad8bf9a776bba8f30a97f49f80d58eb6d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8bf9a776bba8f30a97f49f80d58eb6d">AreClassicalBitsOnSameHost</a> (size_t bitId1, size_t bitId2) const =0</td></tr>
<tr class="memdesc:ad8bf9a776bba8f30a97f49f80d58eb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified classical bits are on the same host.  <br /></td></tr>
<tr class="memitem:aa0c6505b65db2babf16a3f2c9f8d6a00" id="r_aa0c6505b65db2babf16a3f2c9f8d6a00"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0c6505b65db2babf16a3f2c9f8d6a00">AreQubitAndClassicalBitOnSameHost</a> (size_t qubitId, size_t bitId) const =0</td></tr>
<tr class="memdesc:aa0c6505b65db2babf16a3f2c9f8d6a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified qubit and classical bit are on the same host.  <br /></td></tr>
<tr class="memitem:ab6bc597ecc0cd7adbfd5b7b400c1d079" id="r_ab6bc597ecc0cd7adbfd5b7b400c1d079"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6bc597ecc0cd7adbfd5b7b400c1d079">GetHostIdForQubit</a> (size_t qubitId) const =0</td></tr>
<tr class="memdesc:ab6bc597ecc0cd7adbfd5b7b400c1d079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the host id for the specified qubit.  <br /></td></tr>
<tr class="memitem:ab6ba8cc6b58268fba46720be9f0adb20" id="r_ab6ba8cc6b58268fba46720be9f0adb20"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6ba8cc6b58268fba46720be9f0adb20">GetHostIdForEntangledQubit</a> (size_t qubitId) const =0</td></tr>
<tr class="memdesc:ab6ba8cc6b58268fba46720be9f0adb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the host id for the specified qubit used for entanglement between hosts.  <br /></td></tr>
<tr class="memitem:a2f22f9d7758999f2d318b2d11b4ad5f0" id="r_a2f22f9d7758999f2d318b2d11b4ad5f0"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f22f9d7758999f2d318b2d11b4ad5f0">GetHostIdForAnyQubit</a> (size_t qubitId) const =0</td></tr>
<tr class="memdesc:a2f22f9d7758999f2d318b2d11b4ad5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the host id for the specified qubit.  <br /></td></tr>
<tr class="memitem:affc2d3e3400bd8246e576a97c829a42c" id="r_affc2d3e3400bd8246e576a97c829a42c"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affc2d3e3400bd8246e576a97c829a42c">GetHostIdForClassicalBit</a> (size_t classicalBitId) const =0</td></tr>
<tr class="memdesc:affc2d3e3400bd8246e576a97c829a42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the host id for the specified classical bit.  <br /></td></tr>
<tr class="memitem:a4684d4fb1f0f53a48bdf9cb673a51845" id="r_a4684d4fb1f0f53a48bdf9cb673a51845"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4684d4fb1f0f53a48bdf9cb673a51845">GetQubitsIds</a> (size_t hostId) const =0</td></tr>
<tr class="memdesc:a4684d4fb1f0f53a48bdf9cb673a51845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the qubit ids for the specified host.  <br /></td></tr>
<tr class="memitem:af1ed31e3fd4c550c08ee15df2bc8e2d2" id="r_af1ed31e3fd4c550c08ee15df2bc8e2d2"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1ed31e3fd4c550c08ee15df2bc8e2d2">GetNetworkEntangledQubitsIds</a> (size_t hostId) const =0</td></tr>
<tr class="memdesc:af1ed31e3fd4c550c08ee15df2bc8e2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the qubit ids used for entanglement between hosts for the specified host.  <br /></td></tr>
<tr class="memitem:a32a22cf71a50794f6cebffb8041e18f7" id="r_a32a22cf71a50794f6cebffb8041e18f7"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32a22cf71a50794f6cebffb8041e18f7">GetClassicalBitsIds</a> (size_t hostId) const =0</td></tr>
<tr class="memdesc:a32a22cf71a50794f6cebffb8041e18f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the classical bit ids for the specified host.  <br /></td></tr>
<tr class="memitem:ae707d7266464fe11cd168a3b29de2250" id="r_ae707d7266464fe11cd168a3b29de2250"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae707d7266464fe11cd168a3b29de2250">GetEntangledQubitMeasurementBitIds</a> (size_t hostId) const =0</td></tr>
<tr class="memdesc:ae707d7266464fe11cd168a3b29de2250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the classical bit ids used for measurement of entanglement qubits between the hosts for the specified host.  <br /></td></tr>
<tr class="memitem:a146fb9a9fa27fad9e7ad44026618b3a3" id="r_a146fb9a9fa27fad9e7ad44026618b3a3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a146fb9a9fa27fad9e7ad44026618b3a3">IsNetworkEntangledQubit</a> (size_t qubitId) const =0</td></tr>
<tr class="memdesc:a146fb9a9fa27fad9e7ad44026618b3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified qubit id is for a qubit used for entanglement between hosts.  <br /></td></tr>
<tr class="memitem:a231e5f0a714696312629cf70dc7ca44f" id="r_a231e5f0a714696312629cf70dc7ca44f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a231e5f0a714696312629cf70dc7ca44f">IsLocalOperation</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;op) const =0</td></tr>
<tr class="memdesc:a231e5f0a714696312629cf70dc7ca44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the circuit operation is local.  <br /></td></tr>
<tr class="memitem:a1a2210a0f608a6ac6ed8e87348cc85c2" id="r_a1a2210a0f608a6ac6ed8e87348cc85c2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a2210a0f608a6ac6ed8e87348cc85c2">IsDistributedOperation</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;op) const =0</td></tr>
<tr class="memdesc:a1a2210a0f608a6ac6ed8e87348cc85c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the circuit operation is distributed.  <br /></td></tr>
<tr class="memitem:a89e9d9a4b65450bacdf43cc3fe0faba2" id="r_a89e9d9a4b65450bacdf43cc3fe0faba2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89e9d9a4b65450bacdf43cc3fe0faba2">OperatesWithNetworkEntangledQubit</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;op) const =0</td></tr>
<tr class="memdesc:a89e9d9a4b65450bacdf43cc3fe0faba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the circuit operation operates on the entanglement qubits between hosts.  <br /></td></tr>
<tr class="memitem:a4c65af505d69a5eb14744ea55dd633c3" id="r_a4c65af505d69a5eb14744ea55dd633c3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c65af505d69a5eb14744ea55dd633c3">SendPacket</a> (size_t fromHostId, size_t toHostId, const std::vector&lt; uint8_t &gt; &amp;packet)=0</td></tr>
<tr class="memdesc:a4c65af505d69a5eb14744ea55dd633c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a packet between two hosts.  <br /></td></tr>
<tr class="memitem:a7940ce3090852de2fd9543bbc3292eb8" id="r_a7940ce3090852de2fd9543bbc3292eb8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7940ce3090852de2fd9543bbc3292eb8">IsEntanglingGate</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;op) const =0</td></tr>
<tr class="memdesc:a7940ce3090852de2fd9543bbc3292eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a gate is an entangling gate.  <br /></td></tr>
<tr class="memitem:a22b353be6b1743c4d2cdd920bbbc180c" id="r_a22b353be6b1743c4d2cdd920bbbc180c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22b353be6b1743c4d2cdd920bbbc180c">ExpectsClassicalBitFromOtherHost</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;op) const =0</td></tr>
<tr class="memdesc:a22b353be6b1743c4d2cdd920bbbc180c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a gate expects a classical bit from another host.  <br /></td></tr>
<tr class="memitem:a9ef908e8ff8166d4c3740389033748cd" id="r_a9ef908e8ff8166d4c3740389033748cd"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ef908e8ff8166d4c3740389033748cd">GetHostIdForClassicalControl</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;op) const =0</td></tr>
<tr class="memdesc:a9ef908e8ff8166d4c3740389033748cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the host id where the classical control bit resides for a conditioned gate.  <br /></td></tr>
<tr class="memitem:aa25d8393ad2adda6ce7c5693fb8aaa53" id="r_aa25d8393ad2adda6ce7c5693fb8aaa53"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa25d8393ad2adda6ce7c5693fb8aaa53">IsEntanglementQubitBusy</a> (size_t qubitId) const =0</td></tr>
<tr class="memdesc:aa25d8393ad2adda6ce7c5693fb8aaa53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified qubit used for entanglement between hosts is busy.  <br /></td></tr>
<tr class="memitem:a693f4ba4a976500057608bb3ff589d2e" id="r_a693f4ba4a976500057608bb3ff589d2e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a693f4ba4a976500057608bb3ff589d2e">AreEntanglementQubitsBusy</a> (size_t qubitId1, size_t qubitId2) const =0</td></tr>
<tr class="memdesc:a693f4ba4a976500057608bb3ff589d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any of the two specified qubits used for entanglement between hosts are busy.  <br /></td></tr>
<tr class="memitem:aca3f0b815a508a20ec442de9bdcd6d2b" id="r_aca3f0b815a508a20ec442de9bdcd6d2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca3f0b815a508a20ec442de9bdcd6d2b">MarkEntangledQubitsBusy</a> (size_t qubitId1, size_t qubitId2)=0</td></tr>
<tr class="memdesc:aca3f0b815a508a20ec442de9bdcd6d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the pair of the specified qubits used for entanglement between hosts as busy.  <br /></td></tr>
<tr class="memitem:aa50510ad514671f454c87392f69bb038" id="r_aa50510ad514671f454c87392f69bb038"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa50510ad514671f454c87392f69bb038">MarkEntangledQubitFree</a> (size_t qubitId)=0</td></tr>
<tr class="memdesc:aa50510ad514671f454c87392f69bb038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the specified qubit used for entanglement between hosts as free.  <br /></td></tr>
<tr class="memitem:a15a187cbee6f0fbea202ce73e8a4e90d" id="r_a15a187cbee6f0fbea202ce73e8a4e90d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15a187cbee6f0fbea202ce73e8a4e90d">ClearEntanglements</a> ()=0</td></tr>
<tr class="memdesc:a15a187cbee6f0fbea202ce73e8a4e90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all entanglements between hosts in the network.  <br /></td></tr>
<tr class="memitem:a75e453a585ee0cc245b7f8b45495c944" id="r_a75e453a585ee0cc245b7f8b45495c944"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75e453a585ee0cc245b7f8b45495c944">getptr</a> ()</td></tr>
<tr class="memdesc:a75e453a585ee0cc245b7f8b45495c944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a shared pointer to this object.  <br /></td></tr>
<tr class="memitem:af4c955f8422f6728514456a8186e8150" id="r_af4c955f8422f6728514456a8186e8150"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceNetwork.html#a33e9851296c0fe8a699eab9c27ec656e">NetworkType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4c955f8422f6728514456a8186e8150">GetType</a> () const =0</td></tr>
<tr class="memdesc:af4c955f8422f6728514456a8186e8150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the network.  <br /></td></tr>
<tr class="memitem:a9dc2a3747334f094ca63c4ad9741bbb2" id="r_a9dc2a3747334f094ca63c4ad9741bbb2"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9dc2a3747334f094ca63c4ad9741bbb2">Clone</a> () const =0</td></tr>
<tr class="memdesc:a9dc2a3747334f094ca63c4ad9741bbb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the network.  <br /></td></tr>
<tr class="memitem:a9de72cfe3605bdb7afba76993195ce9b" id="r_a9de72cfe3605bdb7afba76993195ce9b"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9de72cfe3605bdb7afba76993195ce9b">GetDistributedCircuit</a> () const =0</td></tr>
<tr class="memdesc:a9de72cfe3605bdb7afba76993195ce9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distributed circuit.  <br /></td></tr>
<tr class="memitem:ae0e5c5761d2d2443369978d9416d51d8" id="r_ae0e5c5761d2d2443369978d9416d51d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0e5c5761d2d2443369978d9416d51d8">SetOptimizeSimulator</a> (bool optimize=true)=0</td></tr>
<tr class="memdesc:ae0e5c5761d2d2443369978d9416d51d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows using an optimized simulator.  <br /></td></tr>
<tr class="memitem:ac1fb6303ce4490514280816730b52562" id="r_ac1fb6303ce4490514280816730b52562"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1fb6303ce4490514280816730b52562">GetOptimizeSimulator</a> () const =0</td></tr>
<tr class="memdesc:ac1fb6303ce4490514280816730b52562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 'optimize' flag.  <br /></td></tr>
<tr class="memitem:ab3bc4744d3a0c79ef13f07b33332fce2" id="r_ab3bc4744d3a0c79ef13f07b33332fce2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3bc4744d3a0c79ef13f07b33332fce2">GetLastSimulatorType</a> () const =0</td></tr>
<tr class="memdesc:ab3bc4744d3a0c79ef13f07b33332fce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last used simulator type.  <br /></td></tr>
<tr class="memitem:a05c53ae7f147e63c95cd33dfcd465bb7" id="r_a05c53ae7f147e63c95cd33dfcd465bb7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05c53ae7f147e63c95cd33dfcd465bb7">GetLastSimulationType</a> () const =0</td></tr>
<tr class="memdesc:a05c53ae7f147e63c95cd33dfcd465bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last used simulation type.  <br /></td></tr>
<tr class="memitem:aa36fc37a82fef4eb146f8e931c3d28f5" id="r_aa36fc37a82fef4eb146f8e931c3d28f5"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="#a9b12b44710338adee5d0368b6dd63047">SimulatorsSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa36fc37a82fef4eb146f8e931c3d28f5">GetSimulatorsSet</a> () const =0</td></tr>
<tr class="memdesc:aa36fc37a82fef4eb146f8e931c3d28f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the optimizations simulators set.  <br /></td></tr>
<tr class="memitem:a752bdbaa3348d82f8362c6ae874e5337" id="r_a752bdbaa3348d82f8362c6ae874e5337"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a752bdbaa3348d82f8362c6ae874e5337">AddOptimizationSimulator</a> (<a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a> type, <a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a> kind)=0</td></tr>
<tr class="memdesc:a752bdbaa3348d82f8362c6ae874e5337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a simulator to the simulators optimization set.  <br /></td></tr>
<tr class="memitem:a19058e2cd51add8be754aa68501e138b" id="r_a19058e2cd51add8be754aa68501e138b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19058e2cd51add8be754aa68501e138b">RemoveOptimizationSimulator</a> (<a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a> type, <a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a> kind)=0</td></tr>
<tr class="memdesc:a19058e2cd51add8be754aa68501e138b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a simulator from the simulators optimization set.  <br /></td></tr>
<tr class="memitem:ae731339397d14238715fa4ca68263de0" id="r_ae731339397d14238715fa4ca68263de0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae731339397d14238715fa4ca68263de0">RemoveAllOptimizationSimulatorsAndAdd</a> (<a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a> type, <a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a> kind)=0</td></tr>
<tr class="memdesc:ae731339397d14238715fa4ca68263de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all simulators from the simulators optimization set and adds the one specified.  <br /></td></tr>
<tr class="memitem:a6f83d88bee54c79b77c0e5b2e562c26d" id="r_a6f83d88bee54c79b77c0e5b2e562c26d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f83d88bee54c79b77c0e5b2e562c26d">OptimizationSimulatorExists</a> (<a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a> type, <a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a> kind) const =0</td></tr>
<tr class="memdesc:a6f83d88bee54c79b77c0e5b2e562c26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a simulator exists in the optimization set.  <br /></td></tr>
<tr class="memitem:a52d7eeb7fcc89b7937443a12a8bbd84a" id="r_a52d7eeb7fcc89b7937443a12a8bbd84a"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52d7eeb7fcc89b7937443a12a8bbd84a">GetMaxSimulators</a> () const =0</td></tr>
<tr class="memdesc:a52d7eeb7fcc89b7937443a12a8bbd84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of simulators that can be used in the network.  <br /></td></tr>
<tr class="memitem:a27a20e63e59a20e27cb42f2bdd1184fa" id="r_a27a20e63e59a20e27cb42f2bdd1184fa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27a20e63e59a20e27cb42f2bdd1184fa">SetMaxSimulators</a> (size_t maxSimulators)=0</td></tr>
<tr class="memdesc:a27a20e63e59a20e27cb42f2bdd1184fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of simulators that can be used in the network.  <br /></td></tr>
<tr class="memitem:ad13d2d4aa5bfe7c3379434d5f1a65b83" id="r_ad13d2d4aa5bfe7c3379434d5f1a65b83"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad13d2d4aa5bfe7c3379434d5f1a65b83">GetSubroutinesTextCode</a> () const</td></tr>
<tr class="memdesc:ad13d2d4aa5bfe7c3379434d5f1a65b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the text code that is executed on the hosts.  <br /></td></tr>
<tr class="memitem:a0165dd5bbd0ecafd731da8eab599b7bc" id="r_a0165dd5bbd0ecafd731da8eab599b7bc"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classSimulators_1_1ISimulator.html">Simulators::ISimulator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0165dd5bbd0ecafd731da8eab599b7bc">ChooseBestSimulator</a> (const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;dcirc, size_t &amp;counts, size_t nrQubits, size_t nrCbits, size_t nrResultCbits, <a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a> &amp;simType, <a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a> &amp;method, std::vector&lt; bool &gt; &amp;executed, bool multithreading=false, bool dontRunCircuitStart=false) const =0</td></tr>
<tr class="memdesc:a0165dd5bbd0ecafd731da8eab599b7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose the best simulator for the given circuit.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Time = Types::time_type&gt;<br />
class Network::INetwork&lt; Time &gt;</div><p>The network interface. </p>
<p>The network interface. Must be derived from by the particular network implementations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Time</td><td>The time type used for execution times. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNetwork_1_1IHost.html" title="The host interface.">IHost</a> </dd>
<dd>
<a class="el" href="classNetwork_1_1IController.html" title="The controller host interface.">IController</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Network_8h_source.html#l00056">56</a> of file <a class="el" href="Network_8h_source.html">Network.h</a>.</p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="aa7e4e730dac51e0ae031528ecdfe7378" name="aa7e4e730dac51e0ae031528ecdfe7378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e4e730dac51e0ae031528ecdfe7378">&#9670;&#160;</a></span>ExecuteResults</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::ExecuteResults = typename <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt;Time&gt;::ExecuteResults</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Network_8h_source.html#l00058">58</a> of file <a class="el" href="Network_8h_source.html">Network.h</a>.</p>

</div>
</div>
<a id="ae6c065febe1ab7eb1701e79d89475096" name="ae6c065febe1ab7eb1701e79d89475096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c065febe1ab7eb1701e79d89475096">&#9670;&#160;</a></span>SimulatorPair</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::SimulatorPair</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      std::pair&lt;Simulators::SimulatorType, Simulators::SimulationType&gt;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="Network_8h_source.html#l00059">59</a> of file <a class="el" href="Network_8h_source.html">Network.h</a>.</p>

</div>
</div>
<a id="a9b12b44710338adee5d0368b6dd63047" name="a9b12b44710338adee5d0368b6dd63047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b12b44710338adee5d0368b6dd63047">&#9670;&#160;</a></span>SimulatorsSet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::SimulatorsSet</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      std::unordered_set&lt;SimulatorPair, boost::hash&lt;SimulatorPair&gt;&gt;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="Network_8h_source.html#l00061">61</a> of file <a class="el" href="Network_8h_source.html">Network.h</a>.</p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5ab3268ca8816f31d22c65a7bcdba609" name="a5ab3268ca8816f31d22c65a7bcdba609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab3268ca8816f31d22c65a7bcdba609">&#9670;&#160;</a></span>~INetwork()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::~<a class="el" href="classNetwork_1_1INetwork.html">INetwork</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the <a class="el" href="classNetwork_1_1INetwork.html" title="The network interface.">INetwork</a> object. </p>
<p>Destroy the <a class="el" href="classNetwork_1_1INetwork.html" title="The network interface.">INetwork</a> object. Virtual because this is an interface. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a752bdbaa3348d82f8362c6ae874e5337" name="a752bdbaa3348d82f8362c6ae874e5337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752bdbaa3348d82f8362c6ae874e5337">&#9670;&#160;</a></span>AddOptimizationSimulator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::AddOptimizationSimulator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a></td>          <td class="paramname"><span class="paramname"><em>kind</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a simulator to the simulators optimization set. </p>
<p>Adds a simulator (if not already present) to the simulators optimization set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the simulator to add. </td></tr>
    <tr><td class="paramname">kind</td><td>The kind of the simulation to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a2424468039a56fa0b6d96604db08f828">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="ad8bf9a776bba8f30a97f49f80d58eb6d" name="ad8bf9a776bba8f30a97f49f80d58eb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8bf9a776bba8f30a97f49f80d58eb6d">&#9670;&#160;</a></span>AreClassicalBitsOnSameHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::AreClassicalBitsOnSameHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bitId1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bitId2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the specified classical bits are on the same host. </p>
<p>Check if the specified classical are on the same host. This does not include the classical bits used for measuring the qubits used for entanglement between the hosts.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the specified qubits are on the same host, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#afd15438f447aea77b9fb2a548fc822a8">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a693f4ba4a976500057608bb3ff589d2e" name="a693f4ba4a976500057608bb3ff589d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693f4ba4a976500057608bb3ff589d2e">&#9670;&#160;</a></span>AreEntanglementQubitsBusy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::AreEntanglementQubitsBusy </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if any of the two specified qubits used for entanglement between hosts are busy. </p>
<p>Check if any of the two specified qubits used for entanglement between hosts are busy. This is used to check if the qubits are free in order to use them for creating an entanglement between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubitId1</td><td>The id of the first qubit to check. </td></tr>
    <tr><td class="paramname">qubitId2</td><td>The id of the second qubit to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any of the two specified qubits used for entanglement between hosts are busy, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#ad78a8a5a095c7a67c151b91817baffd0">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="aa0c6505b65db2babf16a3f2c9f8d6a00" name="aa0c6505b65db2babf16a3f2c9f8d6a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c6505b65db2babf16a3f2c9f8d6a00">&#9670;&#160;</a></span>AreQubitAndClassicalBitOnSameHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::AreQubitAndClassicalBitOnSameHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bitId</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the specified qubit and classical bit are on the same host. </p>
<p>Check if the specified qubit and classical bit are on the same host. This does not include the qubits used for entanglement between the hosts and the classical bits used for their measurement.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the specified qubit and classical bit are on the same host, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a6bfc7fbb149632fdf31a0233461e2293">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a59bb55fcc09c35d5aa1c21f5ad2249d1" name="a59bb55fcc09c35d5aa1c21f5ad2249d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59bb55fcc09c35d5aa1c21f5ad2249d1">&#9670;&#160;</a></span>AreQubitsOnSameHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::AreQubitsOnSameHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the specified qubits are on the same host. </p>
<p>Check if the specified qubits are on the same host. This does not include the qubits used for entanglement between the hosts.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the specified qubits are on the same host, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a8097c7e6113ae3df223b56791f69db20">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a0165dd5bbd0ecafd731da8eab599b7bc" name="a0165dd5bbd0ecafd731da8eab599b7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0165dd5bbd0ecafd731da8eab599b7bc">&#9670;&#160;</a></span>ChooseBestSimulator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classSimulators_1_1ISimulator.html">Simulators::ISimulator</a> &gt; <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::ChooseBestSimulator </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dcirc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>counts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nrQubits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nrCbits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nrResultCbits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>simType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>method</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>executed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>multithreading</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>dontRunCircuitStart</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Choose the best simulator for the given circuit. </p>
<p>Choose the best simulator for the given circuit, based on the number of qubits, number of classical bits, number of result classical bits and number of shots. The choice is made from the optimization simulators set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dcirc</td><td>The distributed circuit to choose the simulator for. </td></tr>
    <tr><td class="paramname">counts</td><td>The number of shots to be executed. </td></tr>
    <tr><td class="paramname">nrQubits</td><td>The number of qubits in the circuit. </td></tr>
    <tr><td class="paramname">nrCbits</td><td>The number of classical bits in the circuit. </td></tr>
    <tr><td class="paramname">nrResultCbits</td><td>The number of result classical bits in the circuit. </td></tr>
    <tr><td class="paramname">simType</td><td>The type of the chosen simulator. </td></tr>
    <tr><td class="paramname">method</td><td>The kind of simulation of the chosen simulator. </td></tr>
    <tr><td class="paramname">executed</td><td>A vector of bools marking the executed gates from the circuit (some of them might be executed when picking up the simulator - usually the gates from the beginning up to the measurements/resets). </td></tr>
    <tr><td class="paramname">multithreading</td><td>If true, allows simulators to support multithreading (default is false). Multithreading will be set to false if multithreading is implemented at a higher level (multiple simulators in parallel). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the chosen simulator. </dd></dl>

</div>
</div>
<a id="a15a187cbee6f0fbea202ce73e8a4e90d" name="a15a187cbee6f0fbea202ce73e8a4e90d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a187cbee6f0fbea202ce73e8a4e90d">&#9670;&#160;</a></span>ClearEntanglements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::ClearEntanglements </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all entanglements between hosts in the network. </p>
<p>Clear all entanglements between hosts in the network. This marks all qubits used for entanglement between hosts as free. If the entanglements are explicitely coordinated in the network, all pairs of entangled qubits are released. </p>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#adc457460c0cd933d072808da878b271e">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a9dc2a3747334f094ca63c4ad9741bbb2" name="a9dc2a3747334f094ca63c4ad9741bbb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc2a3747334f094ca63c4ad9741bbb2">&#9670;&#160;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::Clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone the network. </p>
<p>Clone the network in a pristine state. </p><dl class="section return"><dt>Returns</dt><dd>A shared pointer to the cloned network. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a5b1a1277feaaad66db284db1f7fe1569">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a79ac17adf81c745de120e19b78a1743c" name="a79ac17adf81c745de120e19b78a1743c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ac17adf81c745de120e19b78a1743c">&#9670;&#160;</a></span>Configure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::Configure </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configures the network. </p>
<p>This function is called to configure the network (for example the simulator(s) used by the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the configuration option. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the configuration. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a3beaae2be8da41f5362532960cf984aa">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="aad379273cb76f8c2e734fcad6010950e" name="aad379273cb76f8c2e734fcad6010950e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad379273cb76f8c2e734fcad6010950e">&#9670;&#160;</a></span>CreateScheduler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::CreateScheduler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1">SchedulerType</a></td>          <td class="paramname"><span class="paramname"><em>schType</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1ab90c9b48118b61527e8d21a4bb699c4b">SchedulerType::kNoEntanglementQubitsParallel</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the scheduler for the network. </p>
<p>Creates the scheduler for the network. Call this only after the network topology has been set up. Should create the scheduler and set the network for it and any other necessary parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simType</td><td>The type of the scheduler to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1" title="The type of the network scheduler for scheduling execution of multiple circuits.">SchedulerType</a> </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#ac5c495840beeaa043b4b7ec85cd18bb7">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a8e6daa8026a734401c90514b76f12044" name="a8e6daa8026a734401c90514b76f12044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6daa8026a734401c90514b76f12044">&#9670;&#160;</a></span>CreateSimulator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::CreateSimulator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a></td>          <td class="paramname"><span class="paramname"><em>simType</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aaa20dd7a84a53e5ace6f43951e3f0b0337">Simulators::SimulatorType::kQCSim</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a></td>          <td class="paramname"><span class="paramname"><em>simExecType</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789a62f6eb80f4ebe16a28e8405dffac7fea">Simulators::SimulationType::kMatrixProductState</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nrQubits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the simulator for the network. </p>
<p>Creates the simulator for the network. Call this only after the network topology has been set up. Should create the simulator with the proper number of qubits for the whole network and also set up a 'classical state' for the whole network and distribute the qubits and cbits to the hosts. The nrQubits parameter is used internally to allocate a simulator for a single host only - if a circuit is executed on a single host. Let it to the default value - 0 - to allocate the number of qubits for the whole network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simType</td><td>The type of the simulator to create. </td></tr>
    <tr><td class="paramname">simExecType</td><td>The type of the simulation - statevector, composite, matrix product state, stabilizer, tensor network... </td></tr>
    <tr><td class="paramname">nrQubits</td><td>The number of qubits to allocate for the simulator. Default is 0 - allocate the number of qubits for the whole network. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa" title="The type of simulator.">Simulators::SimulatorType</a> </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a3eee70024a100f2d13da135e4fc94214">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a08b1adb6d8cb973553490cdba72ee264" name="a08b1adb6d8cb973553490cdba72ee264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b1adb6d8cb973553490cdba72ee264">&#9670;&#160;</a></span>Execute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::Execute </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the circuit on the network. </p>
<p>Execute the circuit on the network, using the controller for distributing the operations to the hosts. The base class functionality is used for circuit distribution, but then the distributed circuit is converted to netqasm. Ensure the quantum computing simulator and the netqasm virtual machines have been created before calling this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuit</td><td>The circuit to execute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd></dl>

</div>
</div>
<a id="a373c422b6f4a2895bfe95daba2744c35" name="a373c422b6f4a2895bfe95daba2744c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373c422b6f4a2895bfe95daba2744c35">&#9670;&#160;</a></span>ExecuteExpectations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; double &gt; <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::ExecuteExpectations </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>paulis</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the circuit on the network and return the expectation values for the specified Pauli strings. </p>
<p>Execute the circuit on the network, using the controller for distributing the operations to the hosts and return the expectation values for the specified Pauli strings. The base class functionality is used for circuit distribution, but then the distributed circuit is converted to netqasm. Ensure the quantum computing simulator and the netqasm virtual machines have been created before calling this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuit</td><td>The circuit to execute. </td></tr>
    <tr><td class="paramname">paulis</td><td>The Pauli strings to measure the expectations for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd></dl>

</div>
</div>
<a id="ac7b5e621b3f084e00a681c914176bc56" name="ac7b5e621b3f084e00a681c914176bc56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b5e621b3f084e00a681c914176bc56">&#9670;&#160;</a></span>ExecuteOnHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::ExecuteOnHost </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the circuit on the specified host. </p>
<p>Execute the circuit on the specified host. The circuit must fit on the host, otherwise an exception is thrown. The circuit will be mapped on the specified host, if its qubits start with indexing from 0 (if already mapped, the qubits won't be altered).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuit</td><td>The circuit to execute. </td></tr>
    <tr><td class="paramname">hostId</td><td>The id of the host to execute the circuit on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd></dl>

</div>
</div>
<a id="a66764ee7024642ef150d7765abf084a2" name="a66764ee7024642ef150d7765abf084a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66764ee7024642ef150d7765abf084a2">&#9670;&#160;</a></span>ExecuteOnHostExpectations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; double &gt; <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::ExecuteOnHostExpectations </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>paulis</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the circuit on the specified host and return the expectation values for the specified Pauli strings. </p>
<p>Execute the circuit on the specified host and return the expectation values for the specified Pauli strings. The circuit must fit on the host, otherwise an exception is thrown. The circuit will be mapped on the specified host, if its qubits start with indexing from 0 (if already mapped, the qubits won't be altered).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuit</td><td>The circuit to execute. </td></tr>
    <tr><td class="paramname">hostId</td><td>The id of the host to execute the circuit on. </td></tr>
    <tr><td class="paramname">paulis</td><td>The Pauli strings to measure the expectations for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd></dl>

</div>
</div>
<a id="a5e8996656e5c376f82c9b5371931341c" name="a5e8996656e5c376f82c9b5371931341c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8996656e5c376f82c9b5371931341c">&#9670;&#160;</a></span>ExecuteScheduled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="#aa7e4e730dac51e0ae031528ecdfe7378">ExecuteResults</a> &gt; <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::ExecuteScheduled </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structSchedulers_1_1ExecuteCircuit.html">Schedulers::ExecuteCircuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuits</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedule and execute circuits on the network. </p>
<p>Execute the circuits on the network, scheduling their execution and distributing the operations to the hosts. The way the circuits are distributed to the hosts depends on the specific interface implementations. The way they are scheduled depends on the network scheduler and parametrization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuits</td><td>The circuits to execute, along with the number of shots. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of maps with the results of each circuit execution, where the key is the state as a vector of bools and the value is the number of times it was measured. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd>
<dd>
ExecuteCircuit </dd></dl>

</div>
</div>
<a id="a22b353be6b1743c4d2cdd920bbbc180c" name="a22b353be6b1743c4d2cdd920bbbc180c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b353be6b1743c4d2cdd920bbbc180c">&#9670;&#160;</a></span>ExpectsClassicalBitFromOtherHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::ExpectsClassicalBitFromOtherHost </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a gate expects a classical bit from another host. </p>
<p>It must be a conditional gate, conditioned on a classical bit from another host. Use it on already distributed gates, not on the original circuit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified circuit operation needs a classical bit from another host, false otherwise. </dd></dl>

</div>
</div>
<a id="a32a22cf71a50794f6cebffb8041e18f7" name="a32a22cf71a50794f6cebffb8041e18f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a22cf71a50794f6cebffb8041e18f7">&#9670;&#160;</a></span>GetClassicalBitsIds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; size_t &gt; <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetClassicalBitsIds </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the classical bit ids for the specified host. </p>
<p>Get the classical bit ids for the specified host, excluding the one(s) used for measurement of entanglemen qubits between the hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostId</td><td>The id of the host to get the classical bit ids for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with the classical bit ids. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#ac7f34eee1300e60156c75471bd7cdcda">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="af7014ccd32005ed57052893c1973c877" name="af7014ccd32005ed57052893c1973c877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7014ccd32005ed57052893c1973c877">&#9670;&#160;</a></span>GetController()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1IController.html">IController</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetController </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the controller for the network. </p>
<p>Gets a smart pointer to the controller for the network.</p>
<dl class="section return"><dt>Returns</dt><dd>The controller for the network. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNetwork_1_1IController.html" title="The controller host interface.">IController</a> </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#aaaef4e5472e4dd6cc177c5a26a408622">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a9de72cfe3605bdb7afba76993195ce9b" name="a9de72cfe3605bdb7afba76993195ce9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de72cfe3605bdb7afba76993195ce9b">&#9670;&#160;</a></span>GetDistributedCircuit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetDistributedCircuit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the distributed circuit. </p>
<p>Get the distributed circuit. <a class="el" href="#a08b1adb6d8cb973553490cdba72ee264" title="Execute the circuit on the network.">Execute()</a> must be called first, otherwise the return would be nullptr.</p>
<dl class="section return"><dt>Returns</dt><dd>The distributed circuit. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a3128d73e5b2c2a35571b7413a83bd48f">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="ae707d7266464fe11cd168a3b29de2250" name="ae707d7266464fe11cd168a3b29de2250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae707d7266464fe11cd168a3b29de2250">&#9670;&#160;</a></span>GetEntangledQubitMeasurementBitIds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; size_t &gt; <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetEntangledQubitMeasurementBitIds </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the classical bit ids used for measurement of entanglement qubits between the hosts for the specified host. </p>
<p>Get the classical bit ids used for measurement of entanglement qubits between the hosts for the specified host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostId</td><td>The id of the host to get the classical bit ids for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with the classical bit ids. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#ac8499d79e66d8bc04d140d28f7e415d2">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a87e1848fa60b03837f25819af4b7a421" name="a87e1848fa60b03837f25819af4b7a421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e1848fa60b03837f25819af4b7a421">&#9670;&#160;</a></span>GetHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1IHost.html">IHost</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the host with the specified id. </p>
<p>Get a smart pointer to the host that has the specified id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostId</td><td>The id of the host to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the host that has the specified id. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNetwork_1_1IHost.html" title="The host interface.">IHost</a> </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a4190672a3cbcc56a3daacd93555007a8">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a2f22f9d7758999f2d318b2d11b4ad5f0" name="a2f22f9d7758999f2d318b2d11b4ad5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f22f9d7758999f2d318b2d11b4ad5f0">&#9670;&#160;</a></span>GetHostIdForAnyQubit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetHostIdForAnyQubit </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the host id for the specified qubit. </p>
<p>Get the host id for the squbit, including the qubits used for entanglement between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubitId</td><td>The id of the qubit to get the host id for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The host id for the specified qubit. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a87b8db81eb036b773c0adf1875634540">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="affc2d3e3400bd8246e576a97c829a42c" name="affc2d3e3400bd8246e576a97c829a42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc2d3e3400bd8246e576a97c829a42c">&#9670;&#160;</a></span>GetHostIdForClassicalBit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetHostIdForClassicalBit </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>classicalBitId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the host id for the specified classical bit. </p>
<p>Get the host id for the specified classical bit, including the one(s) used for measurement of entanglement qubits between the hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">classicalBitId</td><td>The id of the classical bit to get the host id for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The host id for the specified classical bit. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a36976d5eac2433ba03bf309280d75ce5">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a9ef908e8ff8166d4c3740389033748cd" name="a9ef908e8ff8166d4c3740389033748cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef908e8ff8166d4c3740389033748cd">&#9670;&#160;</a></span>GetHostIdForClassicalControl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetHostIdForClassicalControl </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the host id where the classical control bit resides for a conditioned gate. </p>
<p>It must be a conditional gate, conditioned on a qubit from another host. Use it on already distributed gates, not on the original circuit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to find the host of the control bit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The host id. </dd></dl>

</div>
</div>
<a id="ab6ba8cc6b58268fba46720be9f0adb20" name="ab6ba8cc6b58268fba46720be9f0adb20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ba8cc6b58268fba46720be9f0adb20">&#9670;&#160;</a></span>GetHostIdForEntangledQubit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetHostIdForEntangledQubit </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the host id for the specified qubit used for entanglement between hosts. </p>
<p>Get the host id for the specified qubit used for entanglement between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubitId</td><td>The id of qubit the used for entanglement between hosts to get the host id for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The host id for the specified qubit used for entanglement between hosts. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a04384bbfdd7970e4e4834efa873a6d4f">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="ab6bc597ecc0cd7adbfd5b7b400c1d079" name="ab6bc597ecc0cd7adbfd5b7b400c1d079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bc597ecc0cd7adbfd5b7b400c1d079">&#9670;&#160;</a></span>GetHostIdForQubit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetHostIdForQubit </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the host id for the specified qubit. </p>
<p>Get the host id for the specified qubit, excluding the qubits used for entanglement between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubitId</td><td>The id of the qubit to get the host id for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The host id for the specified qubit. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a4e1c0079ea5ccd1aba336ac04514f2b8">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a05c53ae7f147e63c95cd33dfcd465bb7" name="a05c53ae7f147e63c95cd33dfcd465bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c53ae7f147e63c95cd33dfcd465bb7">&#9670;&#160;</a></span>GetLastSimulationType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a> <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetLastSimulationType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last used simulation type. </p>
<p>Get the last used simulation type.</p>
<dl class="section return"><dt>Returns</dt><dd>The simulation type that was used last time. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a6492ca625156136c2e438083093b2ef7">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="ab3bc4744d3a0c79ef13f07b33332fce2" name="ab3bc4744d3a0c79ef13f07b33332fce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bc4744d3a0c79ef13f07b33332fce2">&#9670;&#160;</a></span>GetLastSimulatorType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a> <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetLastSimulatorType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last used simulator type. </p>
<p>Get the last used simulator type.</p>
<dl class="section return"><dt>Returns</dt><dd>The simulator type that was used last time. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a02697dcb575dadb6060ca5d60ccdeffd">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a52d7eeb7fcc89b7937443a12a8bbd84a" name="a52d7eeb7fcc89b7937443a12a8bbd84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d7eeb7fcc89b7937443a12a8bbd84a">&#9670;&#160;</a></span>GetMaxSimulators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetMaxSimulators </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum number of simulators that can be used in the network. </p>
<p>Get the maximum number of simulators that can be used in the network. This is used to limit the number of simulators (and corresponding threads) that can be used in the network.</p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of simulators that can be used in the network. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#ac384bc3121527e1334aa886ebb21fb87">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="af1ed31e3fd4c550c08ee15df2bc8e2d2" name="af1ed31e3fd4c550c08ee15df2bc8e2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ed31e3fd4c550c08ee15df2bc8e2d2">&#9670;&#160;</a></span>GetNetworkEntangledQubitsIds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; size_t &gt; <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetNetworkEntangledQubitsIds </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the qubit ids used for entanglement between hosts for the specified host. </p>
<p>Get the qubit ids used for entanglement between hosts for the specified host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostId</td><td>The id of the host to get the qubit ids for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with the qubit ids. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#af346a968922fed1b2607879c69616499">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a4a09ddecdeb48ce7e5ef09a67ab813d8" name="a4a09ddecdeb48ce7e5ef09a67ab813d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a09ddecdeb48ce7e5ef09a67ab813d8">&#9670;&#160;</a></span>GetNumberOfGatesDistributedOrCut()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetNumberOfGatesDistributedOrCut </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of gates that span more than one host. </p>
<p>Get the number of gates that span more than one host for the given circuit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuit</td><td>The circuit to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of gates that need distribution or cutting. </dd></dl>

</div>
</div>
<a id="aae2e82505c0d886286a69e5912d49ff8" name="aae2e82505c0d886286a69e5912d49ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2e82505c0d886286a69e5912d49ff8">&#9670;&#160;</a></span>GetNumClassicalBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetNumClassicalBits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of classical bits in the network. </p>
<p>Get the number of classical bits in the network, excluding the classical bits used for measurement of entanglement qubits between the hosts.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of classical bits in the network. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a9dd489fb138feee985beb73a87f4059a">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a06d737a893006c0cab0668921aea6f98" name="a06d737a893006c0cab0668921aea6f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d737a893006c0cab0668921aea6f98">&#9670;&#160;</a></span>GetNumClassicalBitsForHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetNumClassicalBitsForHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of classical bits in the network for the specified host. </p>
<p>Get the number of classical bits in the network for the specified host, excluding the classical bits used for measurement of entanglement qubits between the hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostId</td><td>The id of the host to get the number of classical bits for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of classical bits in the network for the specified host. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a702fc9d436751911472e0cbde2eec518">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a625f23dc01a47dd53cfca1846ae43d7a" name="a625f23dc01a47dd53cfca1846ae43d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625f23dc01a47dd53cfca1846ae43d7a">&#9670;&#160;</a></span>GetNumHosts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetNumHosts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of hosts in the network. </p>
<p>Get the number of hosts in the network, excluding the controller.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of hosts in the network. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a46f9387675110a28a81c10794f3f1c45">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="ab19aa63f1ee949ef027655383ba50aaf" name="ab19aa63f1ee949ef027655383ba50aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19aa63f1ee949ef027655383ba50aaf">&#9670;&#160;</a></span>GetNumNetworkEntangledQubits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetNumNetworkEntangledQubits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of qubits used for entanglement between hosts. </p>
<p>Get the number of qubits used for entanglement between hosts in the network.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of qubits used for entanglement between hosts. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a1b978a5df60184fcf694e53d495b738d">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a28ae2af8f51bb864ff5cde89c3df9bef" name="a28ae2af8f51bb864ff5cde89c3df9bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ae2af8f51bb864ff5cde89c3df9bef">&#9670;&#160;</a></span>GetNumNetworkEntangledQubitsForHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetNumNetworkEntangledQubitsForHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of qubits used for entanglement between hosts for the specified host. </p>
<p>Get the number of qubits used for entanglement between hosts in the network for the specified host. Usually it's a single qubit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostId</td><td>The id of the host to get the number of qubits used for entanglement between hosts for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of qubits used for entanglement between hosts for the specified host. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a8dc46b6119038c7ee8b62c6db36ffb56">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a91ff17ec7e74a480cb9bd84692185377" name="a91ff17ec7e74a480cb9bd84692185377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ff17ec7e74a480cb9bd84692185377">&#9670;&#160;</a></span>GetNumQubits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetNumQubits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of qubits in the network. </p>
<p>Get the number of qubits in the network, excluding the qubits used for entanglement between the hosts.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of qubits in the network. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a31c2704fa3dc82eaf63005774231deca">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a9a3d9fa2fb43484c48dc0494ca3a7bc0" name="a9a3d9fa2fb43484c48dc0494ca3a7bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3d9fa2fb43484c48dc0494ca3a7bc0">&#9670;&#160;</a></span>GetNumQubitsForHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetNumQubitsForHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of qubits in the network for the specified host. </p>
<p>Get the number of qubits in the network for the specified host, excluding the qubits used for entanglement between the hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostId</td><td>The id of the host to get the number of qubits for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of qubits in the network for the specified host. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a22737771248b0de2aaa230360db6cdf0">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="ac1fb6303ce4490514280816730b52562" name="ac1fb6303ce4490514280816730b52562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fb6303ce4490514280816730b52562">&#9670;&#160;</a></span>GetOptimizeSimulator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetOptimizeSimulator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the 'optimize' flag. </p>
<p>Returns the flag set by <a class="el" href="#ae0e5c5761d2d2443369978d9416d51d8" title="Allows using an optimized simulator.">SetOptimizeSimulator()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The 'optimize' flag. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a329778029550a5ead52e77e1966ecb40">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a75e453a585ee0cc245b7f8b45495c944" name="a75e453a585ee0cc245b7f8b45495c944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e453a585ee0cc245b7f8b45495c944">&#9670;&#160;</a></span>getptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::getptr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a shared pointer to this object. </p>
<p>Returns a shared pointer to this object. The object needs to be already wrapped in a shared pointer. </p><dl class="section return"><dt>Returns</dt><dd>A shared pointer to this object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Network_8h_source.html#l00733">733</a> of file <a class="el" href="Network_8h_source.html">Network.h</a>.</p>

</div>
</div>
<a id="a4684d4fb1f0f53a48bdf9cb673a51845" name="a4684d4fb1f0f53a48bdf9cb673a51845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4684d4fb1f0f53a48bdf9cb673a51845">&#9670;&#160;</a></span>GetQubitsIds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; size_t &gt; <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetQubitsIds </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the qubit ids for the specified host. </p>
<p>Get the qubit ids for the specified host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostId</td><td>The id of the host to get the qubit ids for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with the qubit ids. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a2fe97c1659f672739a53021d4a9ec7a8">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a665a3289757c1436f6401ee9f8690312" name="a665a3289757c1436f6401ee9f8690312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665a3289757c1436f6401ee9f8690312">&#9670;&#160;</a></span>GetScheduler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classSchedulers_1_1IScheduler.html">Schedulers::IScheduler</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetScheduler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scheduler for the network. </p>
<p>Get the scheduler for the network.</p>
<dl class="section return"><dt>Returns</dt><dd>The scheduler for the network. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSchedulers_1_1IScheduler.html" title="The scheduler interface.">Schedulers::IScheduler</a> </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a9d2c5711de54c064387946b8381ce250">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a675261875b618da2206a587b487656f3" name="a675261875b618da2206a587b487656f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675261875b618da2206a587b487656f3">&#9670;&#160;</a></span>GetSimulator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classSimulators_1_1ISimulator.html">Simulators::ISimulator</a> &gt; <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetSimulator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the simulator for the network. </p>
<p>Get the simulator for the network.</p>
<dl class="section return"><dt>Returns</dt><dd>The simulator for the network. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimulators_1_1ISimulator.html" title="Interface class for a quantum computing simulator.">Simulators::ISimulator</a> </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#abdba56e38cd3e43847e664791510d980">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="aa36fc37a82fef4eb146f8e931c3d28f5" name="aa36fc37a82fef4eb146f8e931c3d28f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36fc37a82fef4eb146f8e931c3d28f5">&#9670;&#160;</a></span>GetSimulatorsSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="#a9b12b44710338adee5d0368b6dd63047">SimulatorsSet</a> &amp; <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetSimulatorsSet </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the optimizations simulators set. </p>
<p>Get the optimization simulators set. To be used internally, will not be exposed from the library.</p>
<dl class="section return"><dt>Returns</dt><dd>The simulators set. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#ab8a12099dd76cd1c7c63b960405d95a3">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a463a521e8619f91e0130c161e860f5bb" name="a463a521e8619f91e0130c161e860f5bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463a521e8619f91e0130c161e860f5bb">&#9670;&#160;</a></span>GetState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classCircuits_1_1OperationState.html">Circuits::OperationState</a> &amp; <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetState </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the classical state of the network. </p>
<p>Gets a reference to the classical state of the network.</p>
<dl class="section return"><dt>Returns</dt><dd>The classical state of the network. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Circuits::ClassicalState </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a231f579e098ac6597b4c92963ec15f21">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="ad13d2d4aa5bfe7c3379434d5f1a65b83" name="ad13d2d4aa5bfe7c3379434d5f1a65b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13d2d4aa5bfe7c3379434d5f1a65b83">&#9670;&#160;</a></span>GetSubroutinesTextCode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::vector&lt; std::string &gt; &gt; <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetSubroutinesTextCode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the text code that is executed on the hosts. </p>
<p>Get the text code that is executed on the hosts, if available. The circuit might be converted to code to be executed (example: netqasm). If that's the case, the text code is returned in an array, each element of the array being the code for a host. Each host might have multiple subroutines, so each element of the array is an array of strings, each string being a subroutine.</p>
<dl class="section return"><dt>Returns</dt><dd>The text code that is executed on the hosts. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Network_8h_source.html#l00902">902</a> of file <a class="el" href="Network_8h_source.html">Network.h</a>.</p>

</div>
</div>
<a id="af4c955f8422f6728514456a8186e8150" name="af4c955f8422f6728514456a8186e8150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c955f8422f6728514456a8186e8150">&#9670;&#160;</a></span>GetType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceNetwork.html#a33e9851296c0fe8a699eab9c27ec656e">NetworkType</a> <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::GetType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of the network. </p>
<p>Get the type of the network. </p><dl class="section return"><dt>Returns</dt><dd>The type of the network. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceNetwork.html#a33e9851296c0fe8a699eab9c27ec656e" title="The type of the network.">NetworkType</a> </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#af5f9354c22833d18b224930617ee8fe9">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a1a2210a0f608a6ac6ed8e87348cc85c2" name="a1a2210a0f608a6ac6ed8e87348cc85c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2210a0f608a6ac6ed8e87348cc85c2">&#9670;&#160;</a></span>IsDistributedOperation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::IsDistributedOperation </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the circuit operation is distributed. </p>
<p>Check if the specified circuit operation is distributed. A distributed operation is an operation that is executed on multiple hosts. This does not include the operations that also operate on the entanglement qubits between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified circuit operation is distributed, false otherwise. </dd></dl>

</div>
</div>
<a id="aa25d8393ad2adda6ce7c5693fb8aaa53" name="aa25d8393ad2adda6ce7c5693fb8aaa53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25d8393ad2adda6ce7c5693fb8aaa53">&#9670;&#160;</a></span>IsEntanglementQubitBusy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::IsEntanglementQubitBusy </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the specified qubit used for entanglement between hosts is busy. </p>
<p>Check if the specified qubit used for entanglement between hosts is busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubitId</td><td>The id of the qubit to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified qubit used for entanglement between hosts is busy, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#ae929327ee3fe961a4838a6df9bc904bd">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a7940ce3090852de2fd9543bbc3292eb8" name="a7940ce3090852de2fd9543bbc3292eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7940ce3090852de2fd9543bbc3292eb8">&#9670;&#160;</a></span>IsEntanglingGate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::IsEntanglingGate </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a gate is an entangling gate. </p>
<p>An entangling gate is a gate that operates on two qubits that are used for entanglement between hosts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified circuit operation is an entangling gate, false otherwise. </dd></dl>

</div>
</div>
<a id="a231e5f0a714696312629cf70dc7ca44f" name="a231e5f0a714696312629cf70dc7ca44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231e5f0a714696312629cf70dc7ca44f">&#9670;&#160;</a></span>IsLocalOperation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::IsLocalOperation </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the circuit operation is local. </p>
<p>Check if the specified circuit operation is local. A local operation is an operation that is executed on a single host. This does not include the operations that also operate on the entanglement qubits between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified circuit operation is local, false otherwise. </dd></dl>

</div>
</div>
<a id="a146fb9a9fa27fad9e7ad44026618b3a3" name="a146fb9a9fa27fad9e7ad44026618b3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a146fb9a9fa27fad9e7ad44026618b3a3">&#9670;&#160;</a></span>IsNetworkEntangledQubit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::IsNetworkEntangledQubit </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the specified qubit id is for a qubit used for entanglement between hosts. </p>
<p>Check if the specified qubit id is for a qubit used for entanglement between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubitId</td><td>The id of the qubit to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified qubit id is for a qubit used for entanglement between hosts, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a514869063d4a922289c553126ecd9513">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="aa50510ad514671f454c87392f69bb038" name="aa50510ad514671f454c87392f69bb038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50510ad514671f454c87392f69bb038">&#9670;&#160;</a></span>MarkEntangledQubitFree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::MarkEntangledQubitFree </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the specified qubit used for entanglement between hosts as free. </p>
<p>Mark the specified qubit used for entanglement between hosts as free. This is used to mark the qubits as free when they are not used anymore for an entanglement between hosts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubitId</td><td>The id of the qubit to mark as free. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a15e13bf36e6bc35af21916c6c6b5304a">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="aca3f0b815a508a20ec442de9bdcd6d2b" name="aca3f0b815a508a20ec442de9bdcd6d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3f0b815a508a20ec442de9bdcd6d2b">&#9670;&#160;</a></span>MarkEntangledQubitsBusy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::MarkEntangledQubitsBusy </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the pair of the specified qubits used for entanglement between hosts as busy. </p>
<p>Mark the pair of the specified qubits used for entanglement between hosts as busy. This is used to mark the qubits as busy when they are used for creating an entanglement between hosts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubitId1</td><td>The id of the first qubit to mark as busy. </td></tr>
    <tr><td class="paramname">qubitId2</td><td>The id of the second qubit to mark as busy. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#ac4476e8cad5690ab82646d426dabbb02">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a89e9d9a4b65450bacdf43cc3fe0faba2" name="a89e9d9a4b65450bacdf43cc3fe0faba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e9d9a4b65450bacdf43cc3fe0faba2">&#9670;&#160;</a></span>OperatesWithNetworkEntangledQubit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::OperatesWithNetworkEntangledQubit </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1IOperation.html">Circuits::IOperation</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the circuit operation operates on the entanglement qubits between hosts. </p>
<p>Check if the specified circuit operation operates on the entanglement qubits between hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified circuit operation operates on the entanglement qubits between hosts, false otherwise. </dd></dl>

</div>
</div>
<a id="a6f83d88bee54c79b77c0e5b2e562c26d" name="a6f83d88bee54c79b77c0e5b2e562c26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f83d88bee54c79b77c0e5b2e562c26d">&#9670;&#160;</a></span>OptimizationSimulatorExists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::OptimizationSimulatorExists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a></td>          <td class="paramname"><span class="paramname"><em>kind</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a simulator exists in the optimization set. </p>
<p>Checks if a simulator exists in the optimization set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the simulator to check. </td></tr>
    <tr><td class="paramname">kind</td><td>The kind of the simulation to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the simulator exists in the optimization set, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a1943e1e449c97dccd8af0d8791071399">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="ae731339397d14238715fa4ca68263de0" name="ae731339397d14238715fa4ca68263de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae731339397d14238715fa4ca68263de0">&#9670;&#160;</a></span>RemoveAllOptimizationSimulatorsAndAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::RemoveAllOptimizationSimulatorsAndAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a></td>          <td class="paramname"><span class="paramname"><em>kind</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all simulators from the simulators optimization set and adds the one specified. </p>
<p>Removes all simulators from the simulators optimization set and adds the one specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the simulator to add. </td></tr>
    <tr><td class="paramname">kind</td><td>The kind of the simulation to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#aed8f20ae183d2357bdfda05ec88d2450">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a19058e2cd51add8be754aa68501e138b" name="a19058e2cd51add8be754aa68501e138b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19058e2cd51add8be754aa68501e138b">&#9670;&#160;</a></span>RemoveOptimizationSimulator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::RemoveOptimizationSimulator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a68fec15db9b51accdfe4c6d69f2536aa">Simulators::SimulatorType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimulators.html#a36be947268c6955a4a9f323ee6e7c789">Simulators::SimulationType</a></td>          <td class="paramname"><span class="paramname"><em>kind</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a simulator from the simulators optimization set. </p>
<p>Removes a simulator from the simulators optimization set, if it exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the simulator to remove. </td></tr>
    <tr><td class="paramname">kind</td><td>The kind of the simulation to remove. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a5823dfcf86f0df4872a16d7b9eb89d65">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a19cbf8ca93efdc7d9e2c1bae521e5065" name="a19cbf8ca93efdc7d9e2c1bae521e5065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19cbf8ca93efdc7d9e2c1bae521e5065">&#9670;&#160;</a></span>RepeatedExecute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#aa7e4e730dac51e0ae031528ecdfe7378">ExecuteResults</a> <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::RepeatedExecute </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>shots</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the circuit on the network, repeatedly. </p>
<p>Execute the circuit on the network, distributing the operations to the hosts, repeating the execution 'shots' times. The way the circuit is distributed to the hosts depends on the specific interface implementations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuit</td><td>The circuit to execute. </td></tr>
    <tr><td class="paramname">shots</td><td>The number of times to repeat the execution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of maps with the results of each circuit execution, where the key is the state as a vector of bools and the value is the number of times it was measured. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd></dl>

</div>
</div>
<a id="a494d28f1e405949d50dbfda9feee3950" name="a494d28f1e405949d50dbfda9feee3950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494d28f1e405949d50dbfda9feee3950">&#9670;&#160;</a></span>RepeatedExecuteCircuit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aa7e4e730dac51e0ae031528ecdfe7378">ExecuteResults</a> <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::RepeatedExecuteCircuit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSchedulers_1_1ExecuteCircuit.html">Schedulers::ExecuteCircuit</a>&lt; Time &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>executeCircuit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the circuit on the network, repeatedly. </p>
<p>Execute the circuit on the network, distributing the operations to the hosts, repeating the execution 'shots' times. The way the circuit is distributed to the hosts depends on the specific interface implementations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executeCircuit</td><td>The circuit to execute, together with the number of shots. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of maps with the results of each circuit execution, where the key is the state as a vector of bools and the value is the number of times it was measured. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd>
<dd>
ExecuteCircuit </dd></dl>

<p class="definition">Definition at line <a class="el" href="Network_8h_source.html#l00184">184</a> of file <a class="el" href="Network_8h_source.html">Network.h</a>.</p>

</div>
</div>
<a id="a2642458270fe90107586695b550fac51" name="a2642458270fe90107586695b550fac51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2642458270fe90107586695b550fac51">&#9670;&#160;</a></span>RepeatedExecuteCircuitOnHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aa7e4e730dac51e0ae031528ecdfe7378">ExecuteResults</a> <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::RepeatedExecuteCircuitOnHost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSchedulers_1_1ExecuteCircuit.html">Schedulers::ExecuteCircuit</a>&lt; Time &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>executeCircuit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the circuit on the specified host, repeatedly. </p>
<p>Execute the circuit on the specified host, repeating the execution 'shots' times. The circuit must fit on the host, otherwise an exception is thrown. The circuit will be mapped on the specified host, if its qubits start with indexing from 0 (if already mapped, the qubits won't be altered).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executeCircuit</td><td>The circuit to execute, together with the number of shots. </td></tr>
    <tr><td class="paramname">hostId</td><td>The id of the host to execute the circuit on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of maps with the results of each circuit execution, where the key is the state as a vector of bools and the value is the number of times it was measured. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd>
<dd>
ExecuteCircuit </dd></dl>

<p class="definition">Definition at line <a class="el" href="Network_8h_source.html#l00226">226</a> of file <a class="el" href="Network_8h_source.html">Network.h</a>.</p>

</div>
</div>
<a id="a4c390106c9a7fbd4860052fc38b96665" name="a4c390106c9a7fbd4860052fc38b96665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c390106c9a7fbd4860052fc38b96665">&#9670;&#160;</a></span>RepeatedExecuteOnHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#aa7e4e730dac51e0ae031528ecdfe7378">ExecuteResults</a> <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::RepeatedExecuteOnHost </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>shots</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the circuit on the specified host, repeatedly. </p>
<p>Execute the circuit on the specified host, repeating the execution 'shots' times. The circuit must fit on the host, otherwise an exception is thrown. The circuit will be mapped on the specified host, if its qubits start with indexing from 0 (if already mapped, the qubits won't be altered).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circuit</td><td>The circuit to execute. </td></tr>
    <tr><td class="paramname">hostId</td><td>The id of the host to execute the circuit on. </td></tr>
    <tr><td class="paramname">shots</td><td>The number of times to repeat the execution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of maps with the results of each circuit execution, where the key is the state as a vector of bools and the value is the number of times it was measured. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd></dl>

</div>
</div>
<a id="a4c65af505d69a5eb14744ea55dd633c3" name="a4c65af505d69a5eb14744ea55dd633c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c65af505d69a5eb14744ea55dd633c3">&#9670;&#160;</a></span>SendPacket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::SendPacket </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>fromHostId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>toHostId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>packet</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a packet between two hosts. </p>
<p>Sends a packet between the two specified hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromHostId</td><td>The id of the host to send the packet from. </td></tr>
    <tr><td class="paramname">toHostId</td><td>The id of the host to send the packet to. </td></tr>
    <tr><td class="paramname">packet</td><td>The packet to send. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the packet was sent successfully, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#ab79d8495b514562b0358ce37d63ceb2b">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="a27a20e63e59a20e27cb42f2bdd1184fa" name="a27a20e63e59a20e27cb42f2bdd1184fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a20e63e59a20e27cb42f2bdd1184fa">&#9670;&#160;</a></span>SetMaxSimulators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::SetMaxSimulators </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxSimulators</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of simulators that can be used in the network. </p>
<p>Set the maximum number of simulators that can be used in the network. This is used to limit the number of simulators (and corresponding threads) that can be used in the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxSimulators</td><td>The maximum number of simulators that can be used in the network. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a666367ed32af514cc8a653bc06bc293a">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<a id="ae0e5c5761d2d2443369978d9416d51d8" name="ae0e5c5761d2d2443369978d9416d51d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e5c5761d2d2443369978d9416d51d8">&#9670;&#160;</a></span>SetOptimizeSimulator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classNetwork_1_1INetwork.html">Network::INetwork</a>&lt; Time &gt;::SetOptimizeSimulator </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>optimize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows using an optimized simulator. </p>
<p>If set, allows changing the simulator with an optimized one. States/amplitudes are not available in such a case, disable if you need them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optimize</td><td>If true, the simulator will be optimized if possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleDisconnectedNetwork.html#a6f51d41faf736e0e8cb9ebe236ff6b88">Network::SimpleDisconnectedNetwork&lt; Time, Controller &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Controller_8h_source.html">Controller.h</a></li>
<li><a class="el" href="Network_8h_source.html">Network.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceNetwork.html">Network</a></li><li class="navelem"><a href="classNetwork_1_1INetwork.html">INetwork</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for Maestro by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
