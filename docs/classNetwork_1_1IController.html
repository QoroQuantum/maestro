<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Maestro: Network::IController&lt; Time &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Maestro<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Unified interface for quantum circuit simulation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classNetwork_1_1IController.html','','classNetwork_1_1IController-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Network::IController&lt; Time &gt; Class Template Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The controller host interface.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Controller_8h_source.html">Controller.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Network::IController&lt; Time &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classNetwork_1_1IController.png" usemap="#Network_3A_3AIController_3C_20Time_20_3E_map" alt=""/>
  <map id="Network_3A_3AIController_3C_20Time_20_3E_map" name="Network_3A_3AIController_3C_20Time_20_3E_map">
<area href="classNetwork_1_1IHost.html" alt="Network::IHost&lt; Types::time_type &gt;" shape="rect" coords="0,56,345,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0b8d720542f6d1ebab9048dd64a7827b" id="r_a0b8d720542f6d1ebab9048dd64a7827b"><td class="memItemLeft">virtual std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a0b8d720542f6d1ebab9048dd64a7827b">DistributeCircuit</a> (const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; &amp;network, const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit)=0</td></tr>
<tr class="memdesc:a0b8d720542f6d1ebab9048dd64a7827b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributes the circuit on the hosts.  <br /></td></tr>
<tr class="memitem:ab5588898545d076f581476b15afeec2b" id="r_ab5588898545d076f581476b15afeec2b"><td class="memItemLeft">virtual std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#ab5588898545d076f581476b15afeec2b">SplitCompositeOperations</a> (const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; &amp;network, const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit)=0</td></tr>
<tr class="memdesc:ab5588898545d076f581476b15afeec2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the composite operations from the circuit.  <br /></td></tr>
<tr class="memitem:a579bd523d1a647dc918f15d59540ed18" id="r_a579bd523d1a647dc918f15d59540ed18"><td class="memItemLeft">virtual void&#160;</td><td class="memItemRight"><a class="el" href="#a579bd523d1a647dc918f15d59540ed18">SetRemapper</a> (const std::shared_ptr&lt; <a class="el" href="classDistribution_1_1IRemapper.html">Distribution::IRemapper</a>&lt; Time &gt; &gt; &amp;remapper)=0</td></tr>
<tr class="memdesc:a579bd523d1a647dc918f15d59540ed18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the remapper that is used for remapping a circuit to a distributed one.  <br /></td></tr>
<tr class="memitem:ae242cfad490396e663e719888dc27686" id="r_ae242cfad490396e663e719888dc27686"><td class="memItemLeft">virtual std::shared_ptr&lt; <a class="el" href="classDistribution_1_1IRemapper.html">Distribution::IRemapper</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#ae242cfad490396e663e719888dc27686">GetRemapper</a> () const =0</td></tr>
<tr class="memdesc:ae242cfad490396e663e719888dc27686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the remapper that is used for remapping a circuit to a distributed one.  <br /></td></tr>
<tr class="memitem:a3f5fd1dbec76385c23e93f2fe6a3f424" id="r_a3f5fd1dbec76385c23e93f2fe6a3f424"><td class="memItemLeft">virtual std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a3f5fd1dbec76385c23e93f2fe6a3f424">DoNetworkSpecificConversionsForDistribution</a> (const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; &amp;network, const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit)=0</td></tr>
<tr class="memdesc:a3f5fd1dbec76385c23e93f2fe6a3f424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the circuit for distribution for specific networks.  <br /></td></tr>
<tr class="memitem:a473d6bc2e0d54703bcca29c459f54958" id="r_a473d6bc2e0d54703bcca29c459f54958"><td class="memItemLeft">virtual std::shared_ptr&lt; <a class="el" href="classGraphs_1_1IOptimiser.html">Graphs::IOptimiser</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a473d6bc2e0d54703bcca29c459f54958">GetOptimiser</a> () const =0</td></tr>
<tr class="memdesc:a473d6bc2e0d54703bcca29c459f54958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the optimiser used.  <br /></td></tr>
<tr class="memitem:a632b85a870f7ff7e753282ce9be3428f" id="r_a632b85a870f7ff7e753282ce9be3428f"><td class="memItemLeft">virtual void&#160;</td><td class="memItemRight"><a class="el" href="#a632b85a870f7ff7e753282ce9be3428f">CreateOptimiser</a> (<a class="el" href="namespaceGraphs.html#acdb58859f8c4185c1d9ef818cbb04a1c">Graphs::OptimiserType</a> type)=0</td></tr>
<tr class="memdesc:a632b85a870f7ff7e753282ce9be3428f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optimiser.  <br /></td></tr>
<tr class="memitem:a91cd18440112ea6ed917a412c005c9c7" id="r_a91cd18440112ea6ed917a412c005c9c7"><td class="memItemLeft">virtual void&#160;</td><td class="memItemRight"><a class="el" href="#a91cd18440112ea6ed917a412c005c9c7">CreateScheduler</a> (const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; &amp;network, <a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1">SchedulerType</a> schType=<a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1ab90c9b48118b61527e8d21a4bb699c4b">SchedulerType::kNoEntanglementQubitsParallel</a>)=0</td></tr>
<tr class="memdesc:a91cd18440112ea6ed917a412c005c9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the scheduler for the network.  <br /></td></tr>
<tr class="memitem:ac3f2c389fb94dc340dd58dd017f17022" id="r_ac3f2c389fb94dc340dd58dd017f17022"><td class="memItemLeft">virtual std::shared_ptr&lt; <a class="el" href="classSchedulers_1_1IScheduler.html">Schedulers::IScheduler</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#ac3f2c389fb94dc340dd58dd017f17022">GetScheduler</a> () const =0</td></tr>
<tr class="memdesc:ac3f2c389fb94dc340dd58dd017f17022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scheduler for the network.  <br /></td></tr>
<tr class="memitem:a8d9e651e0a6d1a0579be22863fcfbbdc" id="r_a8d9e651e0a6d1a0579be22863fcfbbdc"><td class="memItemLeft">virtual void&#160;</td><td class="memItemRight"><a class="el" href="#a8d9e651e0a6d1a0579be22863fcfbbdc">SetOptimizeCircuit</a> (bool optimize=true)=0</td></tr>
<tr class="memdesc:a8d9e651e0a6d1a0579be22863fcfbbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set circuit optimization.  <br /></td></tr>
<tr class="memitem:a0bc4fa85ebc5be03e8d618cf25bbdc98" id="r_a0bc4fa85ebc5be03e8d618cf25bbdc98"><td class="memItemLeft">virtual bool&#160;</td><td class="memItemRight"><a class="el" href="#a0bc4fa85ebc5be03e8d618cf25bbdc98">GetOptimizeCircuit</a> () const =0</td></tr>
<tr class="memdesc:a0bc4fa85ebc5be03e8d618cf25bbdc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get circuit optimization.  <br /></td></tr>
<tr class="memitem:a18d2c6af150c490e745d01dde6b92785" id="r_a18d2c6af150c490e745d01dde6b92785"><td class="memItemLeft">virtual bool&#160;</td><td class="memItemRight"><a class="el" href="#a18d2c6af150c490e745d01dde6b92785">GetOptimizeRotationGates</a> () const =0</td></tr>
<tr class="memitem:a5f2b7962e1572d29e4b26c5a15f98d18" id="r_a5f2b7962e1572d29e4b26c5a15f98d18"><td class="memItemLeft">virtual void&#160;</td><td class="memItemRight"><a class="el" href="#a5f2b7962e1572d29e4b26c5a15f98d18">SetOptimizeRotationGates</a> (bool val=true)=0</td></tr>
<tr class="inherit_header pub_methods_classNetwork_1_1IHost"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classNetwork_1_1IHost')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="classNetwork_1_1IHost.html">Network::IHost&lt; Types::time_type &gt;</a></td></tr>
<tr class="memitem:a1b528179aeef80f4488d6cba77d67a49 inherit pub_methods_classNetwork_1_1IHost" id="r_a1b528179aeef80f4488d6cba77d67a49"><td class="memItemLeft">virtual&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#a1b528179aeef80f4488d6cba77d67a49">~IHost</a> ()=default</td></tr>
<tr class="memdesc:a1b528179aeef80f4488d6cba77d67a49 inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor.  <br /></td></tr>
<tr class="memitem:afd89083471ba5ad022be8db79640b941 inherit pub_methods_classNetwork_1_1IHost" id="r_afd89083471ba5ad022be8db79640b941"><td class="memItemLeft">virtual size_t&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#afd89083471ba5ad022be8db79640b941">GetId</a> () const=0</td></tr>
<tr class="memdesc:afd89083471ba5ad022be8db79640b941 inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the host id.  <br /></td></tr>
<tr class="memitem:af68c103b5b1c09c07f27c48e684cccd1 inherit pub_methods_classNetwork_1_1IHost" id="r_af68c103b5b1c09c07f27c48e684cccd1"><td class="memItemLeft">virtual size_t&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#af68c103b5b1c09c07f27c48e684cccd1">GetNumQubits</a> () const=0</td></tr>
<tr class="memdesc:af68c103b5b1c09c07f27c48e684cccd1 inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of qubits.  <br /></td></tr>
<tr class="memitem:a8f838c9d994e57e91e16836405ecaeda inherit pub_methods_classNetwork_1_1IHost" id="r_a8f838c9d994e57e91e16836405ecaeda"><td class="memItemLeft">virtual size_t&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#a8f838c9d994e57e91e16836405ecaeda">GetNumNetworkEntangledQubits</a> () const=0</td></tr>
<tr class="memdesc:a8f838c9d994e57e91e16836405ecaeda inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of network entangled qubits.  <br /></td></tr>
<tr class="memitem:aba0ddc5d8b1691b87873662343187867 inherit pub_methods_classNetwork_1_1IHost" id="r_aba0ddc5d8b1691b87873662343187867"><td class="memItemLeft">virtual size_t&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#aba0ddc5d8b1691b87873662343187867">GetNumClassicalBits</a> () const=0</td></tr>
<tr class="memdesc:aba0ddc5d8b1691b87873662343187867 inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of classical bits.  <br /></td></tr>
<tr class="memitem:af0079e098343dfe40a4bee62268993cd inherit pub_methods_classNetwork_1_1IHost" id="r_af0079e098343dfe40a4bee62268993cd"><td class="memItemLeft">virtual bool&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#af0079e098343dfe40a4bee62268993cd">IsQubitOnHost</a> (size_t qubitId) const=0</td></tr>
<tr class="memdesc:af0079e098343dfe40a4bee62268993cd inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a qubit is in the host.  <br /></td></tr>
<tr class="memitem:ad9edb2ce068bf021c3c4fa71bdc8c28f inherit pub_methods_classNetwork_1_1IHost" id="r_ad9edb2ce068bf021c3c4fa71bdc8c28f"><td class="memItemLeft">virtual bool&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#ad9edb2ce068bf021c3c4fa71bdc8c28f">AreQubitsOnSameHost</a> (size_t qubitId1, size_t qubitId2) const=0</td></tr>
<tr class="memdesc:ad9edb2ce068bf021c3c4fa71bdc8c28f inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two qubits are in the same host.  <br /></td></tr>
<tr class="memitem:a0eeb1c6db1c83322cad8810be966382b inherit pub_methods_classNetwork_1_1IHost" id="r_a0eeb1c6db1c83322cad8810be966382b"><td class="memItemLeft">virtual bool&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#a0eeb1c6db1c83322cad8810be966382b">IsClassicalBitOnHost</a> (size_t cbitId) const=0</td></tr>
<tr class="memdesc:a0eeb1c6db1c83322cad8810be966382b inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a classical bit is in the host.  <br /></td></tr>
<tr class="memitem:a54ad03b909ab2d3a3b362a63ebe3001c inherit pub_methods_classNetwork_1_1IHost" id="r_a54ad03b909ab2d3a3b362a63ebe3001c"><td class="memItemLeft">virtual bool&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#a54ad03b909ab2d3a3b362a63ebe3001c">AreCbitsOnSameHost</a> (size_t cbitId1, size_t cbitId2) const=0</td></tr>
<tr class="memdesc:a54ad03b909ab2d3a3b362a63ebe3001c inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two classical bits are in the same host.  <br /></td></tr>
<tr class="memitem:aa09ff405ae85ed07bfa8c7ea15c73b6c inherit pub_methods_classNetwork_1_1IHost" id="r_aa09ff405ae85ed07bfa8c7ea15c73b6c"><td class="memItemLeft">virtual bool&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#aa09ff405ae85ed07bfa8c7ea15c73b6c">IsEntangledQubitOnHost</a> (size_t qubitId) const=0</td></tr>
<tr class="memdesc:aa09ff405ae85ed07bfa8c7ea15c73b6c inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a qubit used for entanglement between hosts is in the host.  <br /></td></tr>
<tr class="memitem:af7b1ed7b1bd1541f81233a362f67973e inherit pub_methods_classNetwork_1_1IHost" id="r_af7b1ed7b1bd1541f81233a362f67973e"><td class="memItemLeft">virtual std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#af7b1ed7b1bd1541f81233a362f67973e">GetQubitsIds</a> () const=0</td></tr>
<tr class="memdesc:af7b1ed7b1bd1541f81233a362f67973e inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ids of the qubits in the host.  <br /></td></tr>
<tr class="memitem:a8f7b703f3933a24a3c6a29a4927a9df5 inherit pub_methods_classNetwork_1_1IHost" id="r_a8f7b703f3933a24a3c6a29a4927a9df5"><td class="memItemLeft">virtual std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#a8f7b703f3933a24a3c6a29a4927a9df5">GetClassicalBitsIds</a> () const=0</td></tr>
<tr class="memdesc:a8f7b703f3933a24a3c6a29a4927a9df5 inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ids of the classical bits in the host.  <br /></td></tr>
<tr class="memitem:a4d953d5a028d8360d707b8dc424f6cac inherit pub_methods_classNetwork_1_1IHost" id="r_a4d953d5a028d8360d707b8dc424f6cac"><td class="memItemLeft">virtual std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#a4d953d5a028d8360d707b8dc424f6cac">GetNetworkEntangledQubitsIds</a> () const=0</td></tr>
<tr class="memdesc:a4d953d5a028d8360d707b8dc424f6cac inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ids of the qubits used for entanglement between hosts in the host.  <br /></td></tr>
<tr class="memitem:a48ece486a1918ea264c57a3c731731b4 inherit pub_methods_classNetwork_1_1IHost" id="r_a48ece486a1918ea264c57a3c731731b4"><td class="memItemLeft">virtual std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#a48ece486a1918ea264c57a3c731731b4">GetEntangledQubitMeasurementBitIds</a> () const=0</td></tr>
<tr class="memdesc:a48ece486a1918ea264c57a3c731731b4 inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ids of the classical bits used for measurement of the qubits used for entanglement between hosts present in the host.  <br /></td></tr>
<tr class="memitem:a32fe533df1f19248eb536c15330df4ca inherit pub_methods_classNetwork_1_1IHost" id="r_a32fe533df1f19248eb536c15330df4ca"><td class="memItemLeft">virtual bool&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#a32fe533df1f19248eb536c15330df4ca">SendPacketToHost</a> (size_t hostId, const std::vector&lt; uint8_t &gt; &amp;packet)=0</td></tr>
<tr class="memdesc:a32fe533df1f19248eb536c15330df4ca inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a packet to a host.  <br /></td></tr>
<tr class="memitem:a5f35a0472a1d13273973707195668a64 inherit pub_methods_classNetwork_1_1IHost" id="r_a5f35a0472a1d13273973707195668a64"><td class="memItemLeft">virtual bool&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#a5f35a0472a1d13273973707195668a64">RecvPacketFromHost</a> (size_t hostId, const std::vector&lt; uint8_t &gt; &amp;packet)=0</td></tr>
<tr class="memdesc:a5f35a0472a1d13273973707195668a64 inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a packet from a host.  <br /></td></tr>
<tr class="memitem:a314fd58887556ee1144cdcfaf518a6a7 inherit pub_methods_classNetwork_1_1IHost" id="r_a314fd58887556ee1144cdcfaf518a6a7"><td class="memItemLeft">virtual size_t&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#a314fd58887556ee1144cdcfaf518a6a7">GetStartQubitId</a> () const=0</td></tr>
<tr class="memdesc:a314fd58887556ee1144cdcfaf518a6a7 inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of the first qubit assigned to the host.  <br /></td></tr>
<tr class="memitem:a99d5a16a2376a5310688fdd08dce2db2 inherit pub_methods_classNetwork_1_1IHost" id="r_a99d5a16a2376a5310688fdd08dce2db2"><td class="memItemLeft">virtual size_t&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#a99d5a16a2376a5310688fdd08dce2db2">GetStartClassicalBitId</a> () const=0</td></tr>
<tr class="memdesc:a99d5a16a2376a5310688fdd08dce2db2 inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of the first classical bit assigned to the host.  <br /></td></tr>
<tr class="memitem:a8873a0e223baed8218e06c289820eaf1 inherit pub_methods_classNetwork_1_1IHost" id="r_a8873a0e223baed8218e06c289820eaf1"><td class="memItemLeft">std::shared_ptr&lt; <a class="el" href="classNetwork_1_1IHost.html">IHost</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="classNetwork_1_1IHost.html#a8873a0e223baed8218e06c289820eaf1">getptr</a> ()</td></tr>
<tr class="memdesc:a8873a0e223baed8218e06c289820eaf1 inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a shared pointer to this object.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Time = Types::time_type&gt;<br />
class Network::IController&lt; Time &gt;</div><p>The controller host interface. </p>
<p>The controller is a special kind of host, it is the one that distributes the circuit to the other hosts.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Time</td><td>The time representation to use for execution times. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNetwork_1_1IHost.html" title="The host interface.">IHost</a> </dd>
<dd>
<a class="el" href="classNetwork_1_1INetwork.html" title="The network interface.">INetwork</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Controller_8h_source.html#l00105">105</a> of file <a class="el" href="Controller_8h_source.html">Controller.h</a>.</p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a632b85a870f7ff7e753282ce9be3428f" name="a632b85a870f7ff7e753282ce9be3428f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632b85a870f7ff7e753282ce9be3428f">&#9670;&#160;</a></span>CreateOptimiser()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classNetwork_1_1IController.html">Network::IController</a>&lt; Time &gt;::CreateOptimiser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGraphs.html#acdb58859f8c4185c1d9ef818cbb04a1c">Graphs::OptimiserType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an optimiser. </p>
<p>Creates an optimiser of the specified type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of optimiser to create. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleController.html#a20f8a39ff5ae94d61e1207d0636915f1">Network::SimpleController&lt; Time &gt;</a>.</p>

</div>
</div>
<a id="a91cd18440112ea6ed917a412c005c9c7" name="a91cd18440112ea6ed917a412c005c9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cd18440112ea6ed917a412c005c9c7">&#9670;&#160;</a></span>CreateScheduler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classNetwork_1_1IController.html">Network::IController</a>&lt; Time &gt;::CreateScheduler </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>network</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1">SchedulerType</a></td>          <td class="paramname"><span class="paramname"><em>schType</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1ab90c9b48118b61527e8d21a4bb699c4b">SchedulerType::kNoEntanglementQubitsParallel</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the scheduler for the network. </p>
<p>Creates the scheduler for the network. Call this only after the network topology has been set up. Should create the scheduler and set the network for it and any other necessary parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>The network to create the scheduler for. </td></tr>
    <tr><td class="paramname">simType</td><td>The type of the scheduler to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1" title="The type of the network scheduler for scheduling execution of multiple circuits.">SchedulerType</a> </dd></dl>

</div>
</div>
<a id="a0b8d720542f6d1ebab9048dd64a7827b" name="a0b8d720542f6d1ebab9048dd64a7827b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8d720542f6d1ebab9048dd64a7827b">&#9670;&#160;</a></span>DistributeCircuit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1IController.html">Network::IController</a>&lt; Time &gt;::DistributeCircuit </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>network</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distributes the circuit on the hosts. </p>
<p>The network will call this, the conversion and distribution that should happen before execution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>The network to distribute the circuit for. </td></tr>
    <tr><td class="paramname">circuit</td><td>The circuit to distribute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distributed circuit. </dd></dl>

</div>
</div>
<a id="a3f5fd1dbec76385c23e93f2fe6a3f424" name="a3f5fd1dbec76385c23e93f2fe6a3f424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5fd1dbec76385c23e93f2fe6a3f424">&#9670;&#160;</a></span>DoNetworkSpecificConversionsForDistribution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1IController.html">Network::IController</a>&lt; Time &gt;::DoNetworkSpecificConversionsForDistribution </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>network</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the circuit for distribution for specific networks. </p>
<p>Convert the circuit for distribution for specific networks. Particular networks might need additional circuit conversions before distribution. They should override this implementation. By default, it does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>The network to convert the circuit for. </td></tr>
    <tr><td class="paramname">circuit</td><td>The circuit to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted circuit. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd></dl>

</div>
</div>
<a id="a473d6bc2e0d54703bcca29c459f54958" name="a473d6bc2e0d54703bcca29c459f54958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473d6bc2e0d54703bcca29c459f54958">&#9670;&#160;</a></span>GetOptimiser()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classGraphs_1_1IOptimiser.html">Graphs::IOptimiser</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1IController.html">Network::IController</a>&lt; Time &gt;::GetOptimiser </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the optimiser used. </p>
<p>Returns the optimiser used. Could be nullptr, that is, no optimiser.</p>
<dl class="section return"><dt>Returns</dt><dd>The optimiser used. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleController.html#a5c8a0616929d338ea72c8d90bd548bd3">Network::SimpleController&lt; Time &gt;</a>.</p>

</div>
</div>
<a id="a0bc4fa85ebc5be03e8d618cf25bbdc98" name="a0bc4fa85ebc5be03e8d618cf25bbdc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc4fa85ebc5be03e8d618cf25bbdc98">&#9670;&#160;</a></span>GetOptimizeCircuit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classNetwork_1_1IController.html">Network::IController</a>&lt; Time &gt;::GetOptimizeCircuit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get circuit optimization. </p>
<p>Returns true if the circuit will be optimized, false otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the circuit will be optimized, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleController.html#a6d3463d19820f37033fb191ad7e0f46c">Network::SimpleController&lt; Time &gt;</a>.</p>

</div>
</div>
<a id="a18d2c6af150c490e745d01dde6b92785" name="a18d2c6af150c490e745d01dde6b92785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d2c6af150c490e745d01dde6b92785">&#9670;&#160;</a></span>GetOptimizeRotationGates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classNetwork_1_1IController.html">Network::IController</a>&lt; Time &gt;::GetOptimizeRotationGates </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleController.html#ac9eb5f4f2781973d21ef2d30510f0211">Network::SimpleController&lt; Time &gt;</a>.</p>

</div>
</div>
<a id="ae242cfad490396e663e719888dc27686" name="ae242cfad490396e663e719888dc27686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae242cfad490396e663e719888dc27686">&#9670;&#160;</a></span>GetRemapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classDistribution_1_1IRemapper.html">Distribution::IRemapper</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1IController.html">Network::IController</a>&lt; Time &gt;::GetRemapper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the remapper that is used for remapping a circuit to a distributed one. </p>
<p>The remapper is used to remap the circuit to a distributed one.</p>
<dl class="section return"><dt>Returns</dt><dd>The remapper. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDistribution_1_1IRemapper.html" title="Remapper abstract class.">Distribution::IRemapper</a> </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleController.html#a717a35af3139bbfebe361555f250c687">Network::SimpleController&lt; Time &gt;</a>.</p>

</div>
</div>
<a id="ac3f2c389fb94dc340dd58dd017f17022" name="ac3f2c389fb94dc340dd58dd017f17022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f2c389fb94dc340dd58dd017f17022">&#9670;&#160;</a></span>GetScheduler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classSchedulers_1_1IScheduler.html">Schedulers::IScheduler</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1IController.html">Network::IController</a>&lt; Time &gt;::GetScheduler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scheduler for the network. </p>
<p>Get the scheduler for the network.</p>
<dl class="section return"><dt>Returns</dt><dd>The scheduler for the network. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSchedulers_1_1IScheduler.html" title="The scheduler interface.">Schedulers::IScheduler</a> </dd></dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleController.html#a4bd3a50170c0369f3c762443fb33fef6">Network::SimpleController&lt; Time &gt;</a>.</p>

</div>
</div>
<a id="a8d9e651e0a6d1a0579be22863fcfbbdc" name="a8d9e651e0a6d1a0579be22863fcfbbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9e651e0a6d1a0579be22863fcfbbdc">&#9670;&#160;</a></span>SetOptimizeCircuit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classNetwork_1_1IController.html">Network::IController</a>&lt; Time &gt;::SetOptimizeCircuit </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>optimize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set circuit optimization. </p>
<p>If the parameter is true, the circuit will be optimized, otherwise it will not be optimized. The default value is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optimize</td><td>True if the circuit should be optimized, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleController.html#a424a15472a91d0ad6df6059a9c0ea1ea">Network::SimpleController&lt; Time &gt;</a>.</p>

</div>
</div>
<a id="a5f2b7962e1572d29e4b26c5a15f98d18" name="a5f2b7962e1572d29e4b26c5a15f98d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2b7962e1572d29e4b26c5a15f98d18">&#9670;&#160;</a></span>SetOptimizeRotationGates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classNetwork_1_1IController.html">Network::IController</a>&lt; Time &gt;::SetOptimizeRotationGates </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>val</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classNetwork_1_1SimpleController.html#a32fe264f2acf266438899bee7ad85e31">Network::SimpleController&lt; Time &gt;</a>.</p>

</div>
</div>
<a id="a579bd523d1a647dc918f15d59540ed18" name="a579bd523d1a647dc918f15d59540ed18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579bd523d1a647dc918f15d59540ed18">&#9670;&#160;</a></span>SetRemapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classNetwork_1_1IController.html">Network::IController</a>&lt; Time &gt;::SetRemapper </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classDistribution_1_1IRemapper.html">Distribution::IRemapper</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>remapper</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the remapper that is used for remapping a circuit to a distributed one. </p>
<p>The remapper is used to remap the circuit to a distributed one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remapper</td><td>The new remapper. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDistribution_1_1IRemapper.html" title="Remapper abstract class.">Distribution::IRemapper</a> </dd></dl>

</div>
</div>
<a id="ab5588898545d076f581476b15afeec2b" name="ab5588898545d076f581476b15afeec2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5588898545d076f581476b15afeec2b">&#9670;&#160;</a></span>SplitCompositeOperations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1IController.html">Network::IController</a>&lt; Time &gt;::SplitCompositeOperations </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>network</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits the composite operations from the circuit. </p>
<p>Splits some composite operations. There are composite operations - other than multiple qubits quantum gates - that act on multiple qubits/classical bits that might act on qubits that are not local. This function splits those operations into ones that act on a single qubit/classical bit. For example measurements on several qubits are split into several measurements on a single qubit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>The network to execute the circuit for. </td></tr>
    <tr><td class="paramname">circuit</td><td>The circuit to execute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the modified circuit. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd>
<dd>
<a class="el" href="classNetwork_1_1INetwork.html" title="The network interface.">INetwork</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Controller_8h_source.html">Controller.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceNetwork.html">Network</a></li><li class="navelem"><a href="classNetwork_1_1IController.html">IController</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for Maestro by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.1 </li>
  </ul>
</div>
</body>
</html>
