<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Maestro: Network::SimpleController&lt; Time &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Maestro<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Unified interface for quantum circuit simulation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classNetwork_1_1SimpleController.html','','classNetwork_1_1SimpleController-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Network::SimpleController&lt; Time &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The simple controller host implementation.
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Network::SimpleController&lt; Time &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classNetwork_1_1SimpleController.png" usemap="#Network_3A_3ASimpleController_3C_20Time_20_3E_map" alt=""/>
  <map id="Network_3A_3ASimpleController_3C_20Time_20_3E_map" name="Network_3A_3ASimpleController_3C_20Time_20_3E_map">
<area href="classNetwork_1_1IController.html" alt="Network::IController&lt; Types::time_type &gt;" shape="rect" coords="0,112,345,136"/>
<area href="classNetwork_1_1IHost.html" alt="Network::IHost&lt; Types::time_type &gt;" shape="rect" coords="0,56,345,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2131c40325052c870ebcdf08b9ca01f1" id="r_a2131c40325052c870ebcdf08b9ca01f1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2131c40325052c870ebcdf08b9ca01f1">DistributeCircuit</a> (const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; &amp;network, const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit) override</td></tr>
<tr class="memdesc:a2131c40325052c870ebcdf08b9ca01f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributes the circuit on the hosts.  <br /></td></tr>
<tr class="memitem:a195f037c7560d63fc1c41ac979eaf6cd" id="r_a195f037c7560d63fc1c41ac979eaf6cd"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a195f037c7560d63fc1c41ac979eaf6cd">SplitCompositeOperations</a> (const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; &amp;network, const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit) override</td></tr>
<tr class="memdesc:a195f037c7560d63fc1c41ac979eaf6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the composite operations from the circuit.  <br /></td></tr>
<tr class="memitem:aae568066568a45ad7455f6016e794cff" id="r_aae568066568a45ad7455f6016e794cff"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae568066568a45ad7455f6016e794cff">GetId</a> () const override</td></tr>
<tr class="memdesc:aae568066568a45ad7455f6016e794cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the host id.  <br /></td></tr>
<tr class="memitem:aa5afaefc59b1913111c20a879f44b010" id="r_aa5afaefc59b1913111c20a879f44b010"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5afaefc59b1913111c20a879f44b010">GetNumQubits</a> () const override</td></tr>
<tr class="memdesc:aa5afaefc59b1913111c20a879f44b010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of qubits.  <br /></td></tr>
<tr class="memitem:abd6585b4c8559fb4f7edb676508ae310" id="r_abd6585b4c8559fb4f7edb676508ae310"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd6585b4c8559fb4f7edb676508ae310">GetNumNetworkEntangledQubits</a> () const override</td></tr>
<tr class="memdesc:abd6585b4c8559fb4f7edb676508ae310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of network entangled qubits.  <br /></td></tr>
<tr class="memitem:a211b38fd822d2031335516e4b4114308" id="r_a211b38fd822d2031335516e4b4114308"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a211b38fd822d2031335516e4b4114308">GetNumClassicalBits</a> () const override</td></tr>
<tr class="memdesc:a211b38fd822d2031335516e4b4114308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of classical bits.  <br /></td></tr>
<tr class="memitem:a02a42920af6dfabd8bdf2b2d3af36d60" id="r_a02a42920af6dfabd8bdf2b2d3af36d60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02a42920af6dfabd8bdf2b2d3af36d60">IsQubitOnHost</a> (size_t qubitId) const override</td></tr>
<tr class="memdesc:a02a42920af6dfabd8bdf2b2d3af36d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a qubit is in the host.  <br /></td></tr>
<tr class="memitem:a878bc8759d0f2bf54bfeb5d4c9235b14" id="r_a878bc8759d0f2bf54bfeb5d4c9235b14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a878bc8759d0f2bf54bfeb5d4c9235b14">IsClassicalBitOnHost</a> (size_t qubitId) const override</td></tr>
<tr class="memdesc:a878bc8759d0f2bf54bfeb5d4c9235b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a classical bit is in the host.  <br /></td></tr>
<tr class="memitem:a66a31be9178cc09fe79afa4ca82da073" id="r_a66a31be9178cc09fe79afa4ca82da073"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66a31be9178cc09fe79afa4ca82da073">IsEntangledQubitOnHost</a> (size_t qubitId) const override</td></tr>
<tr class="memdesc:a66a31be9178cc09fe79afa4ca82da073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a qubit used for entanglement between hosts is in the host.  <br /></td></tr>
<tr class="memitem:aaccf3771f198edd3aa9e13d49239bc18" id="r_aaccf3771f198edd3aa9e13d49239bc18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaccf3771f198edd3aa9e13d49239bc18">AreQubitsOnSameHost</a> (size_t qubitId1, size_t qubitId2) const override</td></tr>
<tr class="memdesc:aaccf3771f198edd3aa9e13d49239bc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two qubits are in the same host.  <br /></td></tr>
<tr class="memitem:a9ffdd30334bee04474c91cbb149007a8" id="r_a9ffdd30334bee04474c91cbb149007a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ffdd30334bee04474c91cbb149007a8">AreCbitsOnSameHost</a> (size_t qubitId1, size_t qubitId2) const override</td></tr>
<tr class="memdesc:a9ffdd30334bee04474c91cbb149007a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two classical bits are in the same host.  <br /></td></tr>
<tr class="memitem:a8266527cece2bd63d3870965d5b1aa75" id="r_a8266527cece2bd63d3870965d5b1aa75"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8266527cece2bd63d3870965d5b1aa75">GetQubitsIds</a> () const override</td></tr>
<tr class="memdesc:a8266527cece2bd63d3870965d5b1aa75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ids of the qubits in the host.  <br /></td></tr>
<tr class="memitem:a94cadd59730b462f2100755f5e3517e1" id="r_a94cadd59730b462f2100755f5e3517e1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94cadd59730b462f2100755f5e3517e1">GetNetworkEntangledQubitsIds</a> () const override</td></tr>
<tr class="memdesc:a94cadd59730b462f2100755f5e3517e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ids of the qubits used for entanglement between hosts in the host.  <br /></td></tr>
<tr class="memitem:ad39e4206294a84180b0131c570d71d83" id="r_ad39e4206294a84180b0131c570d71d83"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad39e4206294a84180b0131c570d71d83">GetClassicalBitsIds</a> () const override</td></tr>
<tr class="memdesc:ad39e4206294a84180b0131c570d71d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ids of the classical bits in the host.  <br /></td></tr>
<tr class="memitem:a0fd4145f38de3571fc1b6e6b814a8c41" id="r_a0fd4145f38de3571fc1b6e6b814a8c41"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fd4145f38de3571fc1b6e6b814a8c41">GetEntangledQubitMeasurementBitIds</a> () const override</td></tr>
<tr class="memdesc:a0fd4145f38de3571fc1b6e6b814a8c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ids of the classical bits used for measurement of the qubits used for entanglement between hosts present in the host.  <br /></td></tr>
<tr class="memitem:a2899fbc4bcb90a893a53a4ec5839a3ba" id="r_a2899fbc4bcb90a893a53a4ec5839a3ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2899fbc4bcb90a893a53a4ec5839a3ba">SetRemapper</a> (const std::shared_ptr&lt; <a class="el" href="classDistribution_1_1IRemapper.html">Distribution::IRemapper</a>&lt; Time &gt; &gt; &amp;r) override</td></tr>
<tr class="memdesc:a2899fbc4bcb90a893a53a4ec5839a3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the remapper that is used for remapping a circuit to a distributed one.  <br /></td></tr>
<tr class="memitem:a717a35af3139bbfebe361555f250c687" id="r_a717a35af3139bbfebe361555f250c687"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classDistribution_1_1IRemapper.html">Distribution::IRemapper</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a717a35af3139bbfebe361555f250c687">GetRemapper</a> () const override</td></tr>
<tr class="memdesc:a717a35af3139bbfebe361555f250c687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the remapper that is used for remapping a circuit to a distributed one.  <br /></td></tr>
<tr class="memitem:af917bc438ef55c06fe11246bbf00776b" id="r_af917bc438ef55c06fe11246bbf00776b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af917bc438ef55c06fe11246bbf00776b">SendPacketToHost</a> (size_t hostId, const std::vector&lt; uint8_t &gt; &amp;packet) override</td></tr>
<tr class="memdesc:af917bc438ef55c06fe11246bbf00776b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a packet to a host.  <br /></td></tr>
<tr class="memitem:a2635d5f90bd042021fc32123696b8ead" id="r_a2635d5f90bd042021fc32123696b8ead"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2635d5f90bd042021fc32123696b8ead">RecvPacketFromHost</a> (size_t hostId, const std::vector&lt; uint8_t &gt; &amp;packet) override</td></tr>
<tr class="memdesc:a2635d5f90bd042021fc32123696b8ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a packet from a host.  <br /></td></tr>
<tr class="memitem:a3bb46c8c4abca0901e199c5d556a6bce" id="r_a3bb46c8c4abca0901e199c5d556a6bce"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bb46c8c4abca0901e199c5d556a6bce">GetStartQubitId</a> () const override</td></tr>
<tr class="memdesc:a3bb46c8c4abca0901e199c5d556a6bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of the first qubit assigned to the host.  <br /></td></tr>
<tr class="memitem:aea3914209392fee6f7d8ef93d26a46a4" id="r_aea3914209392fee6f7d8ef93d26a46a4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea3914209392fee6f7d8ef93d26a46a4">GetStartClassicalBitId</a> () const override</td></tr>
<tr class="memdesc:aea3914209392fee6f7d8ef93d26a46a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of the first classical bit assigned to the host.  <br /></td></tr>
<tr class="memitem:a5c8a0616929d338ea72c8d90bd548bd3" id="r_a5c8a0616929d338ea72c8d90bd548bd3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classGraphs_1_1IOptimiser.html">Graphs::IOptimiser</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c8a0616929d338ea72c8d90bd548bd3">GetOptimiser</a> () const override</td></tr>
<tr class="memdesc:a5c8a0616929d338ea72c8d90bd548bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the optimiser used.  <br /></td></tr>
<tr class="memitem:a20f8a39ff5ae94d61e1207d0636915f1" id="r_a20f8a39ff5ae94d61e1207d0636915f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20f8a39ff5ae94d61e1207d0636915f1">CreateOptimiser</a> (<a class="el" href="namespaceGraphs.html#acdb58859f8c4185c1d9ef818cbb04a1c">Graphs::OptimiserType</a> type) override</td></tr>
<tr class="memdesc:a20f8a39ff5ae94d61e1207d0636915f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optimiser.  <br /></td></tr>
<tr class="memitem:aa01cf6464ea5a4e9db6559e8940bc2dc" id="r_aa01cf6464ea5a4e9db6559e8940bc2dc"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa01cf6464ea5a4e9db6559e8940bc2dc">DoNetworkSpecificConversionsForDistribution</a> (const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; &amp;network, const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;circuit) override</td></tr>
<tr class="memdesc:aa01cf6464ea5a4e9db6559e8940bc2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the circuit for distribution for specific networks.  <br /></td></tr>
<tr class="memitem:aea1bbdf2539d3a0584c9ba5c6caa9811" id="r_aea1bbdf2539d3a0584c9ba5c6caa9811"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea1bbdf2539d3a0584c9ba5c6caa9811">CreateScheduler</a> (const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; &amp;network, <a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1">SchedulerType</a> schType=<a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1ab90c9b48118b61527e8d21a4bb699c4b">SchedulerType::kNoEntanglementQubitsParallel</a>) override</td></tr>
<tr class="memdesc:aea1bbdf2539d3a0584c9ba5c6caa9811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the scheduler for the network.  <br /></td></tr>
<tr class="memitem:a4bd3a50170c0369f3c762443fb33fef6" id="r_a4bd3a50170c0369f3c762443fb33fef6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classSchedulers_1_1IScheduler.html">Schedulers::IScheduler</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bd3a50170c0369f3c762443fb33fef6">GetScheduler</a> () const override</td></tr>
<tr class="memdesc:a4bd3a50170c0369f3c762443fb33fef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scheduler for the network.  <br /></td></tr>
<tr class="memitem:ac9eb5f4f2781973d21ef2d30510f0211" id="r_ac9eb5f4f2781973d21ef2d30510f0211"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9eb5f4f2781973d21ef2d30510f0211">GetOptimizeRotationGates</a> () const override</td></tr>
<tr class="memitem:a32fe264f2acf266438899bee7ad85e31" id="r_a32fe264f2acf266438899bee7ad85e31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32fe264f2acf266438899bee7ad85e31">SetOptimizeRotationGates</a> (bool val=true) override</td></tr>
<tr class="memitem:a424a15472a91d0ad6df6059a9c0ea1ea" id="r_a424a15472a91d0ad6df6059a9c0ea1ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a424a15472a91d0ad6df6059a9c0ea1ea">SetOptimizeCircuit</a> (bool o=true) override</td></tr>
<tr class="memdesc:a424a15472a91d0ad6df6059a9c0ea1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set circuit optimization.  <br /></td></tr>
<tr class="memitem:a6d3463d19820f37033fb191ad7e0f46c" id="r_a6d3463d19820f37033fb191ad7e0f46c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d3463d19820f37033fb191ad7e0f46c">GetOptimizeCircuit</a> () const override</td></tr>
<tr class="memdesc:a6d3463d19820f37033fb191ad7e0f46c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get circuit optimization.  <br /></td></tr>
<tr class="inherit_header pub_methods_classNetwork_1_1IController"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classNetwork_1_1IController')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="classNetwork_1_1IController.html">Network::IController&lt; Types::time_type &gt;</a></td></tr>
<tr class="memitem:a0b8d720542f6d1ebab9048dd64a7827b inherit pub_methods_classNetwork_1_1IController" id="r_a0b8d720542f6d1ebab9048dd64a7827b"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetwork_1_1IController.html#a0b8d720542f6d1ebab9048dd64a7827b">DistributeCircuit</a> (const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;network, const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;circuit)=0</td></tr>
<tr class="memdesc:a0b8d720542f6d1ebab9048dd64a7827b inherit pub_methods_classNetwork_1_1IController"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributes the circuit on the hosts.  <br /></td></tr>
<tr class="memitem:ab5588898545d076f581476b15afeec2b inherit pub_methods_classNetwork_1_1IController" id="r_ab5588898545d076f581476b15afeec2b"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetwork_1_1IController.html#ab5588898545d076f581476b15afeec2b">SplitCompositeOperations</a> (const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;network, const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;circuit)=0</td></tr>
<tr class="memdesc:ab5588898545d076f581476b15afeec2b inherit pub_methods_classNetwork_1_1IController"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the composite operations from the circuit.  <br /></td></tr>
<tr class="memitem:a579bd523d1a647dc918f15d59540ed18 inherit pub_methods_classNetwork_1_1IController" id="r_a579bd523d1a647dc918f15d59540ed18"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetwork_1_1IController.html#a579bd523d1a647dc918f15d59540ed18">SetRemapper</a> (const std::shared_ptr&lt; <a class="el" href="classDistribution_1_1IRemapper.html">Distribution::IRemapper</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;remapper)=0</td></tr>
<tr class="memdesc:a579bd523d1a647dc918f15d59540ed18 inherit pub_methods_classNetwork_1_1IController"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the remapper that is used for remapping a circuit to a distributed one.  <br /></td></tr>
<tr class="memitem:a3f5fd1dbec76385c23e93f2fe6a3f424 inherit pub_methods_classNetwork_1_1IController" id="r_a3f5fd1dbec76385c23e93f2fe6a3f424"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetwork_1_1IController.html#a3f5fd1dbec76385c23e93f2fe6a3f424">DoNetworkSpecificConversionsForDistribution</a> (const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;network, const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;circuit)=0</td></tr>
<tr class="memdesc:a3f5fd1dbec76385c23e93f2fe6a3f424 inherit pub_methods_classNetwork_1_1IController"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the circuit for distribution for specific networks.  <br /></td></tr>
<tr class="memitem:a91cd18440112ea6ed917a412c005c9c7 inherit pub_methods_classNetwork_1_1IController" id="r_a91cd18440112ea6ed917a412c005c9c7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetwork_1_1IController.html#a91cd18440112ea6ed917a412c005c9c7">CreateScheduler</a> (const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt; &amp;network, <a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1">SchedulerType</a> schType=<a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1ab90c9b48118b61527e8d21a4bb699c4b">SchedulerType::kNoEntanglementQubitsParallel</a>)=0</td></tr>
<tr class="memdesc:a91cd18440112ea6ed917a412c005c9c7 inherit pub_methods_classNetwork_1_1IController"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the scheduler for the network.  <br /></td></tr>
<tr class="inherit_header pub_methods_classNetwork_1_1IHost"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classNetwork_1_1IHost')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="classNetwork_1_1IHost.html">Network::IHost&lt; Types::time_type &gt;</a></td></tr>
<tr class="memitem:a1b528179aeef80f4488d6cba77d67a49 inherit pub_methods_classNetwork_1_1IHost" id="r_a1b528179aeef80f4488d6cba77d67a49"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetwork_1_1IHost.html#a1b528179aeef80f4488d6cba77d67a49">~IHost</a> ()=default</td></tr>
<tr class="memdesc:a1b528179aeef80f4488d6cba77d67a49 inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor.  <br /></td></tr>
<tr class="memitem:a8873a0e223baed8218e06c289820eaf1 inherit pub_methods_classNetwork_1_1IHost" id="r_a8873a0e223baed8218e06c289820eaf1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classNetwork_1_1IHost.html">IHost</a>&lt; <a class="el" href="namespaceTypes.html#a52fa93e2b64e3b6dd139877efb1f536e">Types::time_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetwork_1_1IHost.html#a8873a0e223baed8218e06c289820eaf1">getptr</a> ()</td></tr>
<tr class="memdesc:a8873a0e223baed8218e06c289820eaf1 inherit pub_methods_classNetwork_1_1IHost"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a shared pointer to this object.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-attribs" class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a63e75002e01135135cecf5fb020c0f4b" id="r_a63e75002e01135135cecf5fb020c0f4b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classDistribution_1_1IRemapper.html">Distribution::IRemapper</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63e75002e01135135cecf5fb020c0f4b">remapper</a></td></tr>
<tr class="memdesc:a63e75002e01135135cecf5fb020c0f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The remapper used to remap a circuit to a distributed one.  <br /></td></tr>
<tr class="memitem:a59c8b72cd98624c7f8a90b44477f7a60" id="r_a59c8b72cd98624c7f8a90b44477f7a60"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classGraphs_1_1IOptimiser.html">Graphs::IOptimiser</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59c8b72cd98624c7f8a90b44477f7a60">optimiser</a></td></tr>
<tr class="memitem:ac81b062e180d1ab24641968e557cb33c" id="r_ac81b062e180d1ab24641968e557cb33c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classSchedulers_1_1IScheduler.html">Schedulers::IScheduler</a>&lt; Time &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac81b062e180d1ab24641968e557cb33c">scheduler</a></td></tr>
<tr class="memdesc:ac81b062e180d1ab24641968e557cb33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; The optimiser used to optimise the circuit.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Time = Types::time_type&gt;<br />
class Network::SimpleController&lt; Time &gt;</div><p>The simple controller host implementation. </p>
<p>The controller is a special kind of host, it is the one that distributes the circuit to the other hosts. The simple controller just converts a local circuit to a distributed one.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Time</td><td>The time representation to use for execution times. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNetwork_1_1IController.html" title="The controller host interface.">IController</a> </dd>
<dd>
<a class="el" href="classNetwork_1_1INetwork.html" title="The network interface.">INetwork</a> </dd>
<dd>
SimpleNetwork </dd>
<dd>
<a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00042">42</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a9ffdd30334bee04474c91cbb149007a8" name="a9ffdd30334bee04474c91cbb149007a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ffdd30334bee04474c91cbb149007a8">&#9670;&#160;</a></span>AreCbitsOnSameHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::AreCbitsOnSameHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if two classical bits are in the same host. </p>
<p>Checks if two classical bits with the specified ids are in the same host. The controller is a special host, it's not a quantum computer, so it returns false. </p><dl class="section return"><dt>Returns</dt><dd>True if the classical bits are on the same host, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IHost.html#a54ad03b909ab2d3a3b362a63ebe3001c">Network::IHost&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00221">221</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="aaccf3771f198edd3aa9e13d49239bc18" name="aaccf3771f198edd3aa9e13d49239bc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaccf3771f198edd3aa9e13d49239bc18">&#9670;&#160;</a></span>AreQubitsOnSameHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::AreQubitsOnSameHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if two qubits are in the same host. </p>
<p>Checks if two qubits with the specified ids are in the same host, excluding the one(s) used only for entanglement with other hosts. The controller is a special host, it's not a quantum computer, so it returns false. </p><dl class="section return"><dt>Returns</dt><dd>True if the qubits are on the same host, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IHost.html#ad9edb2ce068bf021c3c4fa71bdc8c28f">Network::IHost&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00209">209</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a20f8a39ff5ae94d61e1207d0636915f1" name="a20f8a39ff5ae94d61e1207d0636915f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f8a39ff5ae94d61e1207d0636915f1">&#9670;&#160;</a></span>CreateOptimiser()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::CreateOptimiser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGraphs.html#acdb58859f8c4185c1d9ef818cbb04a1c">Graphs::OptimiserType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an optimiser. </p>
<p>Creates an optimiser of the specified type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of optimiser to create. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classNetwork_1_1IController.html#a632b85a870f7ff7e753282ce9be3428f">Network::IController&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00379">379</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="aea1bbdf2539d3a0584c9ba5c6caa9811" name="aea1bbdf2539d3a0584c9ba5c6caa9811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1bbdf2539d3a0584c9ba5c6caa9811">&#9670;&#160;</a></span>CreateScheduler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::CreateScheduler </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>network</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1">SchedulerType</a></td>          <td class="paramname"><span class="paramname"><em>schType</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1ab90c9b48118b61527e8d21a4bb699c4b">SchedulerType::kNoEntanglementQubitsParallel</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the scheduler for the network. </p>
<p>Creates the scheduler for the network. Call this only after the network topology has been set up. Should create the scheduler and set the network for it and any other necessary parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simType</td><td>The type of the scheduler to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceNetwork.html#ac346ddd099c23b278866f1367743cce1" title="The type of the network scheduler for scheduling execution of multiple circuits.">SchedulerType</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00416">416</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a2131c40325052c870ebcdf08b9ca01f1" name="a2131c40325052c870ebcdf08b9ca01f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2131c40325052c870ebcdf08b9ca01f1">&#9670;&#160;</a></span>DistributeCircuit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::DistributeCircuit </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>network</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distributes the circuit on the hosts. </p>
<p>The network will call this, the conversion and distribution should happen before execution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>The network to distribute the circuit for. </td></tr>
    <tr><td class="paramname">circuit</td><td>The circuit to distribute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distributed circuit. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00054">54</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="aa01cf6464ea5a4e9db6559e8940bc2dc" name="aa01cf6464ea5a4e9db6559e8940bc2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01cf6464ea5a4e9db6559e8940bc2dc">&#9670;&#160;</a></span>DoNetworkSpecificConversionsForDistribution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::DoNetworkSpecificConversionsForDistribution </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>network</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the circuit for distribution for specific networks. </p>
<p>Convert the circuit for distribution for specific networks. Particular networks might need additional circuit conversions before distribution. They should override this implementation. By default, it does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>The network to convert the circuit for. </td></tr>
    <tr><td class="paramname">circuit</td><td>The circuit to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted circuit. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00399">399</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="ad39e4206294a84180b0131c570d71d83" name="ad39e4206294a84180b0131c570d71d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39e4206294a84180b0131c570d71d83">&#9670;&#160;</a></span>GetClassicalBitsIds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::GetClassicalBitsIds </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ids of the classical bits in the host. </p>
<p>Obtain the ids of the classical bits in the host. The controller is a special host, it's not a quantum computer, so it returns an empty vector. </p><dl class="section return"><dt>Returns</dt><dd>The ids of the classical bits in the host. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IHost.html#a8f7b703f3933a24a3c6a29a4927a9df5">Network::IHost&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00257">257</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a0fd4145f38de3571fc1b6e6b814a8c41" name="a0fd4145f38de3571fc1b6e6b814a8c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd4145f38de3571fc1b6e6b814a8c41">&#9670;&#160;</a></span>GetEntangledQubitMeasurementBitIds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::GetEntangledQubitMeasurementBitIds </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ids of the classical bits used for measurement of the qubits used for entanglement between hosts present in the host. </p>
<p>Obtain the ids of the classical bits used for measurement of the qubits used for entanglement between hosts present in the host. The controller is a special host, it's not a quantum computer, so it returns an empty vector. </p><dl class="section return"><dt>Returns</dt><dd>The ids of the classical bits used for measurement of the qubits used for entanglement between hosts present in the host. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IHost.html#a48ece486a1918ea264c57a3c731731b4">Network::IHost&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00269">269</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="aae568066568a45ad7455f6016e794cff" name="aae568066568a45ad7455f6016e794cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae568066568a45ad7455f6016e794cff">&#9670;&#160;</a></span>GetId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::GetId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the host id. </p>
<p>Obtain a host id used to identify the host in the network. Since this is a special host, it returns the maximum value of size_t.</p>
<dl class="section return"><dt>Returns</dt><dd>The host id. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IHost.html#afd89083471ba5ad022be8db79640b941">Network::IHost&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00137">137</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a94cadd59730b462f2100755f5e3517e1" name="a94cadd59730b462f2100755f5e3517e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cadd59730b462f2100755f5e3517e1">&#9670;&#160;</a></span>GetNetworkEntangledQubitsIds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::GetNetworkEntangledQubitsIds </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ids of the qubits used for entanglement between hosts in the host. </p>
<p>Obtain the ids of the qubits used for entanglement between hosts in the host. The controller is a special host, it's not a quantum computer, so it returns an empty vector. </p><dl class="section return"><dt>Returns</dt><dd>The ids of the qubits used for entanglement between hosts in the host. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IHost.html#a4d953d5a028d8360d707b8dc424f6cac">Network::IHost&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00245">245</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a211b38fd822d2031335516e4b4114308" name="a211b38fd822d2031335516e4b4114308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211b38fd822d2031335516e4b4114308">&#9670;&#160;</a></span>GetNumClassicalBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::GetNumClassicalBits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of classical bits. </p>
<p>Obtain the number of classical bits in the host. The controller is a special host, it's not a quantum computer, so it returns 0. </p><dl class="section return"><dt>Returns</dt><dd>The number of classical bits. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IHost.html#aba0ddc5d8b1691b87873662343187867">Network::IHost&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00168">168</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="abd6585b4c8559fb4f7edb676508ae310" name="abd6585b4c8559fb4f7edb676508ae310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6585b4c8559fb4f7edb676508ae310">&#9670;&#160;</a></span>GetNumNetworkEntangledQubits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::GetNumNetworkEntangledQubits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of network entangled qubits. </p>
<p>Obtain the number of qubits in the host used for entanglement with other hosts. The controller is a special host, it's not a quantum computer, so it returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of network entangled qubits. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IHost.html#a8f838c9d994e57e91e16836405ecaeda">Network::IHost&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00158">158</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="aa5afaefc59b1913111c20a879f44b010" name="aa5afaefc59b1913111c20a879f44b010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5afaefc59b1913111c20a879f44b010">&#9670;&#160;</a></span>GetNumQubits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::GetNumQubits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of qubits. </p>
<p>Obtain the number of qubits in the host, excluding the one(s) used only for entanglement with other hosts. The controller is a special host, it's not a quantum computer, so it returns 0. </p><dl class="section return"><dt>Returns</dt><dd>The number of qubits. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IHost.html#af68c103b5b1c09c07f27c48e684cccd1">Network::IHost&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00147">147</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a5c8a0616929d338ea72c8d90bd548bd3" name="a5c8a0616929d338ea72c8d90bd548bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8a0616929d338ea72c8d90bd548bd3">&#9670;&#160;</a></span>GetOptimiser()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classGraphs_1_1IOptimiser.html">Graphs::IOptimiser</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::GetOptimiser </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the optimiser used. </p>
<p>Returns the optimiser used. Could be nullptr, that is, no optimiser.</p>
<dl class="section return"><dt>Returns</dt><dd>The optimiser used. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IController.html#a473d6bc2e0d54703bcca29c459f54958">Network::IController&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00368">368</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a6d3463d19820f37033fb191ad7e0f46c" name="a6d3463d19820f37033fb191ad7e0f46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3463d19820f37033fb191ad7e0f46c">&#9670;&#160;</a></span>GetOptimizeCircuit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::GetOptimizeCircuit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get circuit optimization. </p>
<p>Returns true if the circuit will be optimized, false otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the circuit will be optimized, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IController.html#a0bc4fa85ebc5be03e8d618cf25bbdc98">Network::IController&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00462">462</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="ac9eb5f4f2781973d21ef2d30510f0211" name="ac9eb5f4f2781973d21ef2d30510f0211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9eb5f4f2781973d21ef2d30510f0211">&#9670;&#160;</a></span>GetOptimizeRotationGates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::GetOptimizeRotationGates </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classNetwork_1_1IController.html#a18d2c6af150c490e745d01dde6b92785">Network::IController&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00437">437</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a8266527cece2bd63d3870965d5b1aa75" name="a8266527cece2bd63d3870965d5b1aa75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8266527cece2bd63d3870965d5b1aa75">&#9670;&#160;</a></span>GetQubitsIds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::GetQubitsIds </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ids of the qubits in the host. </p>
<p>Obtain the ids of the qubits in the host, excluding the one(s) used only for entanglement with other hosts. The controller is a special host, it's not a quantum computer, so it returns an empty vector. </p><dl class="section return"><dt>Returns</dt><dd>The ids of the qubits in the host. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IHost.html#af7b1ed7b1bd1541f81233a362f67973e">Network::IHost&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00233">233</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a717a35af3139bbfebe361555f250c687" name="a717a35af3139bbfebe361555f250c687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717a35af3139bbfebe361555f250c687">&#9670;&#160;</a></span>GetRemapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classDistribution_1_1IRemapper.html">Distribution::IRemapper</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::GetRemapper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the remapper that is used for remapping a circuit to a distributed one. </p>
<p>The remapper is used to remap the circuit to a distributed one.</p>
<dl class="section return"><dt>Returns</dt><dd>The remapper. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDistribution_1_1IRemapper.html" title="Remapper abstract class.">Distribution::IRemapper</a> </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IController.html#ae242cfad490396e663e719888dc27686">Network::IController&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00297">297</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a4bd3a50170c0369f3c762443fb33fef6" name="a4bd3a50170c0369f3c762443fb33fef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd3a50170c0369f3c762443fb33fef6">&#9670;&#160;</a></span>GetScheduler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classSchedulers_1_1IScheduler.html">Schedulers::IScheduler</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::GetScheduler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scheduler for the network. </p>
<p>Get the scheduler for the network.</p>
<dl class="section return"><dt>Returns</dt><dd>The scheduler for the network. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSchedulers_1_1IScheduler.html" title="The scheduler interface.">Schedulers::IScheduler</a> </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IController.html#ac3f2c389fb94dc340dd58dd017f17022">Network::IController&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00433">433</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="aea3914209392fee6f7d8ef93d26a46a4" name="aea3914209392fee6f7d8ef93d26a46a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3914209392fee6f7d8ef93d26a46a4">&#9670;&#160;</a></span>GetStartClassicalBitId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::GetStartClassicalBitId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the id of the first classical bit assigned to the host. </p>
<p>Obtain the id of the first classical bit assigned to the host, the other ones are assigned contiquously.</p>
<dl class="section return"><dt>Returns</dt><dd>The id of the first classical bit assigned to the host. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IHost.html#a99d5a16a2376a5310688fdd08dce2db2">Network::IHost&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00359">359</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a3bb46c8c4abca0901e199c5d556a6bce" name="a3bb46c8c4abca0901e199c5d556a6bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb46c8c4abca0901e199c5d556a6bce">&#9670;&#160;</a></span>GetStartQubitId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::GetStartQubitId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the id of the first qubit assigned to the host. </p>
<p>Obtain the id of the first qubit assigned to the host, the other ones are assigned contiquously.</p>
<dl class="section return"><dt>Returns</dt><dd>The id of the first qubit assigned to the host. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IHost.html#a314fd58887556ee1144cdcfaf518a6a7">Network::IHost&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00349">349</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a878bc8759d0f2bf54bfeb5d4c9235b14" name="a878bc8759d0f2bf54bfeb5d4c9235b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878bc8759d0f2bf54bfeb5d4c9235b14">&#9670;&#160;</a></span>IsClassicalBitOnHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::IsClassicalBitOnHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a classical bit is in the host. </p>
<p>Checks if a classical bit with the specified id is in the host. The controller is a special host, it's not a quantum computer, so it returns false. </p><dl class="section return"><dt>Returns</dt><dd>True if the classical bit is on this host, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IHost.html#a0eeb1c6db1c83322cad8810be966382b">Network::IHost&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00188">188</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a66a31be9178cc09fe79afa4ca82da073" name="a66a31be9178cc09fe79afa4ca82da073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a31be9178cc09fe79afa4ca82da073">&#9670;&#160;</a></span>IsEntangledQubitOnHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::IsEntangledQubitOnHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a qubit used for entanglement between hosts is in the host. </p>
<p>Checks if a qubit used for entanglement between hosts with the specified id is in the host. The controller is a special host, it's not a quantum computer, so it returns false. </p><dl class="section return"><dt>Returns</dt><dd>True if the network entangled qubit is on this host, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IHost.html#aa09ff405ae85ed07bfa8c7ea15c73b6c">Network::IHost&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00199">199</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a02a42920af6dfabd8bdf2b2d3af36d60" name="a02a42920af6dfabd8bdf2b2d3af36d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a42920af6dfabd8bdf2b2d3af36d60">&#9670;&#160;</a></span>IsQubitOnHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::IsQubitOnHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>qubitId</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a qubit is in the host. </p>
<p>Checks if a qubit with the specified id is in the host, excluding the one(s) used only for entanglement with other hosts. The controller is a special host, it's not a quantum computer, so it returns false. </p><dl class="section return"><dt>Returns</dt><dd>True if the qubit is on this host, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IHost.html#af0079e098343dfe40a4bee62268993cd">Network::IHost&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00178">178</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a2635d5f90bd042021fc32123696b8ead" name="a2635d5f90bd042021fc32123696b8ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2635d5f90bd042021fc32123696b8ead">&#9670;&#160;</a></span>RecvPacketFromHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::RecvPacketFromHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>packet</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive a packet from a host. </p>
<p>Receive a packet from a host. Usually called by the network implementation. For the simple network, receiving classical packets is not simulated, so this function does nothing and returns false. Most of network implementations do not simulate sending packets from the controller or receiving packets by the controller, only sending/receiving packets between quantum computers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostId</td><td>The id of the host to receive the packet from. </td></tr>
    <tr><td class="paramname">packet</td><td>The packet to receive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IHost.html#a5f35a0472a1d13273973707195668a64">Network::IHost&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00336">336</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="af917bc438ef55c06fe11246bbf00776b" name="af917bc438ef55c06fe11246bbf00776b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af917bc438ef55c06fe11246bbf00776b">&#9670;&#160;</a></span>SendPacketToHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::SendPacketToHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hostId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>packet</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a packet to a host. </p>
<p>Send a packet to a host. Usually called by the host implementation or perhaps in some cases by the network implementation. For the simple network, sending classical packets is not simulated, so this function does nothing and returns false. Most of network implementations do not simulate sending packets from the controller or receiving packets by the controller, only sending/receiving packets between quantum computers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostId</td><td>The id of the host to send the packet to. </td></tr>
    <tr><td class="paramname">packet</td><td>The packet to send. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False. </dd></dl>

<p>Implements <a class="el" href="classNetwork_1_1IHost.html#a32fe533df1f19248eb536c15330df4ca">Network::IHost&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00316">316</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a424a15472a91d0ad6df6059a9c0ea1ea" name="a424a15472a91d0ad6df6059a9c0ea1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424a15472a91d0ad6df6059a9c0ea1ea">&#9670;&#160;</a></span>SetOptimizeCircuit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::SetOptimizeCircuit </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>o</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set circuit optimization. </p>
<p>If the parameter is true, the circuit will be optimized, otherwise it will not be optimized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optimize</td><td>True if the circuit should be optimized, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classNetwork_1_1IController.html#a8d9e651e0a6d1a0579be22863fcfbbdc">Network::IController&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00453">453</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a32fe264f2acf266438899bee7ad85e31" name="a32fe264f2acf266438899bee7ad85e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fe264f2acf266438899bee7ad85e31">&#9670;&#160;</a></span>SetOptimizeRotationGates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::SetOptimizeRotationGates </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>val</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classNetwork_1_1IController.html#a5f2b7962e1572d29e4b26c5a15f98d18">Network::IController&lt; Types::time_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00441">441</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a2899fbc4bcb90a893a53a4ec5839a3ba" name="a2899fbc4bcb90a893a53a4ec5839a3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2899fbc4bcb90a893a53a4ec5839a3ba">&#9670;&#160;</a></span>SetRemapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::SetRemapper </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classDistribution_1_1IRemapper.html">Distribution::IRemapper</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the remapper that is used for remapping a circuit to a distributed one. </p>
<p>The remapper is used to remap a circuit to a distributed one. A default remapper is already set, so calling this function is optional.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The new remapper. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDistribution_1_1IRemapper.html" title="Remapper abstract class.">Distribution::IRemapper</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00283">283</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a195f037c7560d63fc1c41ac979eaf6cd" name="a195f037c7560d63fc1c41ac979eaf6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a195f037c7560d63fc1c41ac979eaf6cd">&#9670;&#160;</a></span>SplitCompositeOperations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::SplitCompositeOperations </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classNetwork_1_1INetwork.html">INetwork</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>network</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classCircuits_1_1Circuit.html">Circuits::Circuit</a>&lt; Time &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits the composite operations from the circuit. </p>
<p>Splits some composite operations. There are composite operations - other than multiple qubits quantum gates - that act on multiple qubits/classical bits that might act on qubits that are not local. This function splits those operations into ones that act on a single qubit/classical bit. For example measurements on several qubits are split into several measurements on a single qubit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>The network to execute the circuit for. </td></tr>
    <tr><td class="paramname">circuit</td><td>The circuit to execute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the modified circuit. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircuits_1_1Circuit.html" title="Circuit class for holding the sequence of operations.">Circuits::Circuit</a> </dd>
<dd>
<a class="el" href="classNetwork_1_1INetwork.html" title="The network interface.">INetwork</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00121">121</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a59c8b72cd98624c7f8a90b44477f7a60" name="a59c8b72cd98624c7f8a90b44477f7a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c8b72cd98624c7f8a90b44477f7a60">&#9670;&#160;</a></span>optimiser</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classGraphs_1_1IOptimiser.html">Graphs::IOptimiser</a>&lt;Time&gt; &gt; <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::optimiser</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00476">476</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="a63e75002e01135135cecf5fb020c0f4b" name="a63e75002e01135135cecf5fb020c0f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e75002e01135135cecf5fb020c0f4b">&#9670;&#160;</a></span>remapper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classDistribution_1_1IRemapper.html">Distribution::IRemapper</a>&lt;Time&gt; &gt; <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::remapper</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The remapper used to remap a circuit to a distributed one. </p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00466">466</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<a id="ac81b062e180d1ab24641968e557cb33c" name="ac81b062e180d1ab24641968e557cb33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81b062e180d1ab24641968e557cb33c">&#9670;&#160;</a></span>scheduler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Time = Types::time_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classSchedulers_1_1IScheduler.html">Schedulers::IScheduler</a>&lt;Time&gt; &gt; <a class="el" href="classNetwork_1_1SimpleController.html">Network::SimpleController</a>&lt; Time &gt;::scheduler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>&lt; The optimiser used to optimise the circuit. </p>
<p>The scheduler used to schedule the circuits. </p>

<p class="definition">Definition at line <a class="el" href="SimpleController_8h_source.html#l00481">481</a> of file <a class="el" href="SimpleController_8h_source.html">SimpleController.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SimpleController_8h_source.html">SimpleController.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceNetwork.html">Network</a></li><li class="navelem"><a href="classNetwork_1_1SimpleController.html">SimpleController</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for Maestro by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
